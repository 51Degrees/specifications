<!DOCTYPE html><html><head><meta charset="UTF-8">
<style>body {
    font-family: sans-serif;
    font-size: 12pt;
    margin: 5em;
    line-height:1.5;
}

table {
    margin-left: auto;
    margin-right: auto;
}
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
   font-size: 11pt;
}table, th, td {
  padding-left: 10px;  padding-right: 10px;  padding-top: 5px;  padding-bottom: 5px;}pre {
    margin-left: 10em;
    font-size: smaller;
}
</style>
</head><body><h1 id="specifications">Specifications</h1>
<h2 id="introduction">Introduction</h2>
<p>This repository contains specifications for the Pipeline API and some 51Degrees
products.</p>
<h2 id="contents">Contents</h2>
<table>
<thead>
<tr><th> Name                                                                       </th><th> Description                                                                                                                     </th></tr>
</thead>
<tbody>
<tr><td> <a href="pipeline-specification/README.md">Pipeline Specification</a>                 </td><td> Specification for the Pipeline API and its operation. This covers core functionality.                                           </td></tr>
<tr><td> <a href="device-detection-specification/README.md">Device Detection Specification</a> </td><td> Specification for the Device Detection service. This builds on the concepts and features defined in the Pipeline specification. </td></tr>
</tbody>
</table>
<h2 id="notes-for-implementers">Notes for implementers</h2>
<ul>
<li>These specifications are written to be language agnostic. The precise
details of how to implement features is often not specified. This allows
implementers to choose the most appropriate mechanism for the target language.
For example, Java and .NET developers would be familiar with the use of a
fluent builder to create instances. However, a Node.JS developer would not
normally use this approach.</li>
<li><a href="https://github.com/51Degrees/pipeline-java">Java</a> and
<a href="https://github.com/51Degrees/pipeline-dotnet">.NET</a> are considered the reference
implementations. At least one of these should be reviewed by the reader to
see what a real-world implementation of the specification looks like. There
is also <a href="pipeline-specification/reference-implementation-notes.md">a section</a>
containing reflections on the architectural choices made when creating the
Java and .NET versions. This may be helpful when designing future implementations.</li>
<li>URLs in these specifications are fixed. Code comments should include
references to these URLs in order to avoid re-writing the same descriptions
and definitions in multiple places.</li>
<li>CI/CD scripts and the like are out of scope. However, implementers should be
mindful of the requirement to have the ability to build and test the software
in a non-interactive CI/CD environment.</li>
</ul>

<hr/>
<h1 id="table-of-contents">Table of Contents</h1>
<h2 id="pipeline-specifications">Pipeline Specifications</h2>
<p><a href="./README.md">Overview</a></p>
<p><a href="./table-of-contents.md">Table of Contents</a></p>
<p><a href="./stylistic-conventions.md">Stylistic Conventions</a></p>
<h2 id="device-detection-specification">Device Detection Specification</h2>
<p><a href="./device-detection-specification/README.md">Overview</a></p>
<p><a href="./device-detection-specification/data-model.md">Data model</a></p>
<p><a href="./device-detection-specification/packaging-and-structure.md">Packaging</a></p>
<p><a href="./device-detection-specification/usage-examples.md">Usage examples</a></p>
<p><a href="./device-detection-specification/part3/required-examples.md">Required Examples</a></p>
<p><a href="./device-detection-specification/part3/automated-testing.md">Automated Testing</a></p>
<h3 id="pipeline-elements">Pipeline Elements</h3>
<p><a href="./device-detection-specification/part3/pipeline-elements/uach-high-entropy-decoder.md">UA-CH high entropy decoder</a></p>
<p><a href="./device-detection-specification/part3/pipeline-elements/hardware-profile-lookup-cloud.md">Hardware Profile lookup</a></p>
<p><a href="./device-detection-specification/pipeline-elements/device-detection-cloud.md">Device Detection cloud</a></p>
<p><a href="./device-detection-specification/pipeline-elements/device-detection-on-premise.md">Device Detection on-premise</a></p>
<h2 id="pipeline-specification">Pipeline Specification</h2>
<p><a href="./pipeline-specification/README.md">Overview</a></p>
<p><a href="./pipeline-specification/conceptual-overview.md">Conceptual overview</a></p>
<p><a href="./pipeline-specification/reference-implementation-notes.md">Reference implementation architecture notes</a></p>
<p><a href="./pipeline-specification/usage-examples.md">Usage examples</a></p>
<p><a href="./pipeline-specification/packaging-and-structure.md">Packaging and structure</a></p>
<p><a href="./pipeline-specification/part3/required-examples.md">Required Examples</a></p>
<p><a href="./pipeline-specification/part3/automated-testing.md">Automated Testing</a></p>
<h3 id="features">Features</h3>
<p><a href="./pipeline-specification/features/pipeline-configuration.md">Pipeline configuration</a></p>
<p><a href="./pipeline-specification/features/web-integration.md">Web integration</a></p>
<p><a href="./pipeline-specification/features/caching.md">Caching</a></p>
<p><a href="./pipeline-specification/features/thread-safety.md">Thread safety</a></p>
<p><a href="./pipeline-specification/features/exception-handling.md">Exception handling</a></p>
<p><a href="./pipeline-specification/features/evidence.md">Evidence</a></p>
<p><a href="./pipeline-specification/features/resource-cleanup.md">Resource cleanup</a></p>
<p><a href="./pipeline-specification/features/file-system-paths.md">File system paths</a></p>
<p><a href="./pipeline-specification/features/usage-sharing.md">Usage sharing</a></p>
<p><a href="./pipeline-specification/features/properties.md">Properties</a></p>
<p><a href="./pipeline-specification/features/logging.md">Logging</a></p>
<p><a href="./pipeline-specification/features/data-updates.md">Data update</a></p>
<p><a href="./pipeline-specification/features/advertize-accepted-evidence.md">Advertise accepted Evidence</a></p>
<p><a href="./pipeline-specification/features/access-to-results.md">Access to results</a></p>
<h3 id="advanced-features">Advanced Features</h3>
<p><a href="./pipeline-specification/advanced-features/README.md">Overview</a></p>
<p><a href="./pipeline-specification/advanced-features/lazy-loading.md">Lazy loading</a></p>
<p><a href="./pipeline-specification/advanced-features/parallel-processing.md">TODO - write this up.</a></p>
<p><a href="./pipeline-specification/advanced-features/process-cancellation.md">Process cancellation</a></p>
<p><a href="./pipeline-specification/advanced-features/multi-pipeline-elements.md">Multi-Pipeline elements</a></p>
<h3 id="pipeline-elements">Pipeline Elements</h3>
<p><a href="./pipeline-specification/part3/pipeline-elements/sequence-element.md">Sequence Element</a></p>
<p><a href="./pipeline-specification/part3/pipeline-elements/javascript-builder.md">JavaScript Builder Element</a></p>
<p><a href="./pipeline-specification/part3/pipeline-elements/json-builder.md">JSON Builder Element</a></p>
<p><a href="./pipeline-specification/part3/pipeline-elements/cloud-request-engine.md">Cloud Request Engine</a></p>
<p><a href="./pipeline-specification/part3/pipeline-elements/cloud-aspect-engine.md">Cloud Aspect Engine</a></p>
<p><a href="./pipeline-specification/part3/pipeline-elements/set-headers-element.md">Set Headers Element</a></p>
<p><a href="./pipeline-specification/pipeline-elements/usage-sharing-element.md">Usage sharing element</a></p>

<hr/>
<h1 id="stylistic-conventions">Stylistic Conventions</h1>
<p>This document contains some notes on stylistic conventions to be observed
in the specification, and doesn&rsquo;t for part of the specification.</p>
<h2 id="voice">Voice</h2>
<p>51Degrees style guide says to adopt a friendly personal tone
however this is a formal specification, so write in third person.</p>
<ul>
<li>The 51Degrees implementation rather than &ldquo;our&rdquo;</li>
<li>It is recommended rather than we recommend.</li>
</ul>
<h2 id="spelling">Spelling</h2>
<ul>
<li>use US English spelling</li>
<li>possibly hyphenated terms, render as follows:
<ul>
<li>&ldquo;start-up&rdquo;</li>
<li>&ldquo;metadata&rdquo;</li>
<li>&ldquo;website&rdquo;</li>
<li>&ldquo;callback&rdquo;</li>
</ul>
</li>
</ul>
<h2 id="capitalization">Capitalization</h2>
<ul>
<li>JSON</li>
<li>DLL</li>
<li>C#</li>
</ul>
<p>Defined Terms:</p>
<p>Defined Terms are Capitalized.</p>
<ul>
<li>Pipeline</li>
<li>Flow Element</li>
<li>Flow Data</li>
<li>Element Data</li>
<li>Engine</li>
<li>Aspect Engine</li>
<li>Cloud Aspect Engine</li>
<li>Cloud Request Engine</li>
<li>On-premise Engine</li>
<li>Cloud Engine</li>
<li>Sequence Element</li>
<li>Set Headers Element</li>
<li>Device Detection</li>
<li>Evidence</li>
<li>Property</li>
<li>Properties</li>
<li>Flow Data</li>
<li>Resource Key</li>
<li>Aspect</li>
</ul>
<p>Where defined terms are introduced, in Conceptual overview and introductory
material, they are <strong>emboldened</strong> on first occurrence.</p>
<p>Pluralized forms of Defined Terms are capitalized.</p>
<p>Ancillary words that go to make a noun phrase from a defined term are not
capitalized. e.g. Pipeline builder. Aspect Element builder. Property metadata.</p>
<p>Class names, interface names and method names are rendered in monospace e.g. <code>process</code></p>
<p>When referring to an implementation class which is an instantiation
of a concept that has a Defined Term, the name of
the class is used and rendered in monospace e.g. <code>FlowData</code></p>
<h2 id="tables">Tables</h2>
<ul>
<li>Bold column headers</li>
<li>Equal space columns</li>
</ul>
<h2 id="rfc-2119">RFC 2119</h2>
<p>RFC 2119 terms are UPPER CASE when used with the meaning defined in RFC 2119.
Avoid use of the same terms where they do not have the RFC 2119 meaning.</p>
<p>MUST, SHOULD, MUST NOT, SHOULD NOT, MAY etc.</p>
<h2 id="section-heads">Section Heads</h2>
<p>Section heads use sentence case, per company style guide..</p>
<p>When a section head contains a defined term the term retains its
capitalization e.g. Flow Element, and Flow Element builder. The logic for this
is that sentence case would have you say, for example,
&ldquo;Taking a trip to Buenos Aires&rdquo;</p>
<h2 id="checking-adherence-to-conventions">Checking adherence to conventions</h2>
<p>Refer to 51Degrees Style Guide.
Refer to 51Degrees Glossary</p>
<p>IntelliJ has a useful linter for markdown.</p>
<p>Link checking - check all links</p>
<p>Table Formatting - check all tables</p>
<h2 id="consistency">Consistency</h2>
<p>Use the term &ldquo;remote server&rdquo; - not cloud or remote service</p>

<hr/>
<h1 id="device-detection-specification">Device Detection specification</h1>
<h2 id="introduction">Introduction</h2>
<p>This folder structure contains a language agnostic specification for a device
detection Engine that can be used by
the <a href="../pipeline-specification/README.md">51Degrees v4 Pipeline API</a>.
We aim to avoid specific details of classes, interfaces, methods or the like.
The focus is on the behavior rather than the method by which that behavior is
achieved. This allows implementers to choose an architectural approach that is
most appropriate and familiar for uses of the target language.</p>
<h2 id="structure">Structure</h2>
<p>This specification builds on the concepts and features defined in the
<a href="../pipeline-specification/README.md">Pipeline specification</a> the reader should
at least be familiar with the basics from there before reading this.<br />
Structurally, this specification is broken down into separate markdown files
in multiple directories.
If you&rsquo;re not sure where to start, we recommend looking at
<a href="usage-examples.md">usage examples</a> first.</p>

<hr/>
<h1 id="data-model">Data model</h1>
<h2 id="introduction">Introduction</h2>
<p>This document contains the details of the data values returned by 51Degrees
Device Detection.</p>
<h2 id="overview">Overview</h2>
<p>All Engines must populate data objects that
implement <a href="../pipeline-specification/conceptual-overview.md#aspect-data">Aspect Data</a>
as defined in the Pipeline specification.</p>
<p>There are several different Engines for getting information about devices. Each
of these Engines must return data that is interface compatible with the others.</p>
<p>Given an interface <code>IDeviceData</code>, the following table shows what should be
populated by each Engine:</p>
<table>
<thead>
<tr><th> Engine          </th><th> Result                   </th></tr>
</thead>
<tbody>
<tr><td> On-premise      </td><td> IDeviceData              </td></tr>
<tr><td> Cloud           </td><td> IDeviceData              </td></tr>
<tr><td> Hardware lookup </td><td> IList&lt;IDeviceData&gt; </td></tr>
</tbody>
</table>
<h2 id="dynamic-property-recommendations">Dynamic Property recommendations</h2>
<p>The Properties that can be populated by Device Detection are defined within the
data file. As such, they are subject to change over time.</p>
<p>For weakly typed languages, this is usually less of an issue as developers in
these ecosystems are generally more used to the idea of discovering Properties
at runtime. However, there should be clear signposting to locations such as
the <a href="https://51degrees.com/developers/property-dictionary">Property dictionary</a>
in order to help discover what Properties are available.</p>
<p>For strongly typed languages, this is partially handled by being able to access
Property values by name. For more details,
see <a href="../pipeline-specification/conceptual-overview.md#element-data">Element Data</a>
in the Pipeline specification.</p>
<p>However, we also want to provide strongly-typed accessors. This could become a
significant maintenance burden, so a command line utility should be created that
can generate an interface definition and any required implementations from the
metadata embedded in the data files.</p>
<p>This can be used during development as well as within 51Degrees&rsquo; CI/CD
infrastructure to automatically re-generate the code when changes occur, such as
a new Property being added.</p>
<p>Note that there are a few additional
<a href="pipeline-elements/device-detection-on-premise.md#match-metric-properties">match metrics Properties</a>
that do not appear in the data file metadata, but will need to be included in
interfaces, etc.</p>
<h2 id="property-details">Property details</h2>
<p>Each Property should return
an <a href="../pipeline-specification/features/properties.md#null-values">Aspect Property value</a>
in order to support exposing the reason that a value is not set.</p>
<p>TODO - finish links once content is available
Beyond this, there are considerations unique to each Engine. Ensure to review
the details linked below:</p>
<ul>
<li><a href="pipeline-elements/device-detection-on-premise.md#metadata">on-premise</a></li>
<li><a href="pipeline-elements/device-detection-cloud.md#">cloud</a></li>
<li><a href="pipeline-elements/hardware-profile-lookup-cloud.md#">hardware lookup</a></li>
</ul>

<hr/>
<h1 id="packaging">Packaging</h1>
<p>The structure of packages and dependencies is not rigidly enforced. The implementer
should choose the appropriate structure based on the norms of the language they are
working with and the architectural design they have produced.</p>
<p>This document contains recommendations to help inform these decisions.</p>
<ol>
<li>Consider following the <a href="../pipeline-specification/packaging-and-structure.md">recommendations</a>
set out for Pipeline API packages in general.</li>
<li>Device Detection packages should all share a common prefix. For example
&lsquo;FiftyOne.DeviceDetection&rsquo;</li>
<li>As on-premise Device Detection requires a native DLL, it is usually helpful to
split this out into a package that is separate from the more lightweight
Cloud Engine.</li>
<li>Examples and tests should not be included in any published packages.</li>
</ol>
<p>For examples, see 51Degrees Device Detection packages on
<a href="https://www.nuget.org/packages?q=FiftyOne.DeviceDetection">NuGet</a>,
<a href="https://central.sonatype.com/search?namespace=com.51degrees&amp;q=device-detection">Maven</a>
or <a href="https://www.npmjs.com/search?q=fiftyone.devicedetection">NPM</a></p>

<hr/>
<h1 id="usage-examples">Usage examples</h1>
<h2 id="introduction">Introduction</h2>
<p>This document contains descriptions of Device Detection use-cases along with
C# examples.</p>
<p>Many of these examples build on the concepts established in the Pipeline
specification, so it may be helpful to first become familiar with
the <a href="../pipeline-specification/usage-examples.md">usage examples</a> there.</p>
<h2 id="create-a-device-detection-pipeline">Create a Device Detection Pipeline</h2>
<p>There are several different ways that a Pipeline might be created. However, once
created, usage must be as similar as possible.
In particular, a cloud Pipeline must be a drop-in replacement for an on-premise
Pipeline for performing Device Detection and querying the results.</p>
<p>Creating an on-premise Device Detection Pipeline in code:</p>
<pre><code class="language-c#">var deviceDetectionEngine = deviceDetectionHashEngineBuilder
  .SetPerformanceProfile(PerformanceProfiles.MaxPerformance)
  .Build(&quot;data file path&quot;);
var pipeline = pipelineBuilder
  .AddElement(deviceDetectionEngine)
  .Build();
</code></pre>
<p>Creating a Pipeline for Device Detection using the 51Degrees cloud service will
look slightly different:</p>
<pre><code class="language-c#">var cloudEngine = cloudRequestEngineBuilder.Build(resourceKey);
var deviceDetectionEngine = deviceDetectionCloudEngineBuilder.Build();
var pipeline = pipelineBuilder
  .AddElement(cloudEngine)
  .AddElement(deviceDetectionEngine)
  .Build();
</code></pre>
<p>Device Detection Pipelines can also
be <a href="../pipeline-specification/features/build-from-configuration.md">created from configuration</a>.</p>
<pre><code class="language-c#">var pipeline = pipelineBuilder
  .BuildFromConfiguration(configuration);
</code></pre>
<h2 id="simple-device-detection">Simple Device Detection</h2>
<p>A user wishes to find out whether a device is a mobile or not, based on the
User-Agent header.</p>
<pre><code class="language-c#">// The 'using' construct ensures that memory is cleaned up 
// after processing is complete. This is very important for 
// the on-premise implementation.
using(var flowdata = pipeline.CreateFlowData())
{
  flowdata.AddEvidence(Constants.USER_AGENT_KEY, userAgentValue);
  flowdata.Process();

  var isMobile = flowData.Get&lt;IDeviceData&gt;().IsMobile.Value;
}
</code></pre>
<h2 id="property-not-available">Property not available</h2>
<p>A Property might not be available in some scenarios. We need to ensure that the
user is informed of why the Property cannot be accessed and how to gain access
if they want to. This feature is described in more detail, covering more scenarios in
the <a href="../pipeline-specification/features/properties.md#missing-properties">Pipeline specification</a></p>
<pre><code class="language-c#">using(var flowdata = pipeline.CreateFlowData())
{
  flowdata.AddEvidence(Constant.USER_AGENT_KEY, userAgentValue);
  flowdata.Process();

  // Expect an error to be thrown on the line below.
  // The Tac property is only available in the 'TAC' data file. As such
  // it is the least likely to be available.
  // If the TAC data file is being used, then all properties will be 
  // available and this line should not throw an error.
  var tac = flowData.Get&lt;IDeviceData&gt;().Tac;
}
</code></pre>
<h2 id="web-integration">Web integration</h2>
<p>The mechanics of this will differ significantly by language.
See <a href="../pipeline-specification/features/web-integration.md">Pipeline - web integration</a>
for more detail.
However, the outcome should be the same. It must be simple for the user to
create a web application where:</p>
<ol>
<li>Each request (following any filtering, etc) will have all relevant Evidence
values extracted, added to a Flow Data and processed.</li>
<li>This Flow Data will be made available in whatever mechanism is common for
shared web session data in that environment, allowing other components to
easily make use of the Device Detection results.</li>
</ol>
<p>For detailed examples see:
- <a href="https://github.com/51Degrees/device-detection-java/tree/master/device-detection.examples/web/getting-started.cloud">Java getting started web - cloud</a>
- <a href="https://github.com/51Degrees/device-detection-java/tree/master/device-detection.examples/web/getting-started.onprem">Java getting started web - on premise</a>
- <a href="https://github.com/51Degrees/device-detection-dotnet/tree/master/Examples/Cloud/GettingStarted-Web">.NET getting started web - cloud</a>
- <a href="https://github.com/51Degrees/device-detection-dotnet/tree/master/Examples/OnPremise/GettingStarted-Web">.NET getting started web - on premise</a></p>
<h3 id="apple-model-detection">Apple model detection</h3>
<p>Modifying the simple web application described above to be able to correctly
identify Apple models must also be very easy. For example, by adding a line
similar to the following in the HTML:</p>
<pre><code class="language-html">&lt;script async src='51Degrees.core.js' type='text/javascript'&gt;&lt;/script&gt;
</code></pre>
<p>For more details on the expected functionality see
the <a href="../pipeline-specification/features/web-integration.md">web integration</a>
section of the Pipeline specification.</p>
<h2 id="automatic-data-updates">Automatic data updates</h2>
<p>All <a href="../pipeline-specification/features/data-updates.md">data update</a>
functionality should be part of configuration.
This Pipeline creation example demonstrates how to configure the Pipeline to
update the Device Detection data file when needed:</p>
<pre><code class="language-c#">// This parameter must be set to true for auto updates to work
var makeTempCopyOfDataFile = true;
var deviceDetectionEngine = deviceDetectionHashEngineBuilder
  .SetPerformanceProfile(PerformanceProfiles.MaxPerformance)
  .SetLicenseKey(licenseKey)
  .SetAutoUpdate(true)
  .Build(&quot;data file path&quot;, makeTempCopyOfDataFile);
var pipeline = pipelineBuilder
  .AddElement(deviceDetectionEngine);
</code></pre>
<p>For more detailed examples see:
- <a href="https://github.com/51Degrees/device-detection-java/blob/master/device-detection.examples/console/src/main/java/fiftyone/devicedetection/examples/console/UpdateDataFile.java">Java data file updates</a>
- <a href="https://github.com/51Degrees/device-detection-dotnet/blob/master/Examples/OnPremise/UpdateDataFile-Console/Program.cs">.NET data file updates</a></p>
<h2 id="property-metadata">Property metadata</h2>
<p><a href="../pipeline-specification/features/properties.md#property-metadata">Property metadata</a>
must be exposed by the Device Detection Engine.
Note that this information should be available for both cloud and On-premise Engines:</p>
<pre><code class="language-c#">foreach (var property in deviceDetectionEngine.Properties)
{
  // Do something with property data.
}
</code></pre>
<p>For more detailed examples see:
- <a href="https://github.com/51Degrees/device-detection-java/blob/master/device-detection.examples/console/src/main/java/fiftyone/devicedetection/examples/console/MetadataCloud.java#L113">Java cloud metadata</a>
- <a href="https://github.com/51Degrees/device-detection-dotnet/blob/master/Examples/Cloud/Metadata-Console/Program.cs#L111">.NET cloud metadata</a></p>
<h2 id="extended-on-premise-metadata">Extended on-premise metadata</h2>
<p>Additional <a href="pipeline-elements/device-detection-on-premise.md#metadata">Device Detection metadata</a>
must be exposed by the On-premise Engine.</p>
<pre><code class="language-c#">foreach (var component in deviceDetectionEngine.Components)
{
  // Do something with component data.
}
foreach (var profile in deviceDetectionEngine.Profiles)
{
  // Do something with profile data
}
foreach (var value in deviceDetectionEngine.Values)
{
  // Do something with value data
}
</code></pre>
<p>For more detailed examples see:
- <a href="https://github.com/51Degrees/device-detection-java/blob/master/device-detection.examples/console/src/main/java/fiftyone/devicedetection/examples/console/MetadataOnPrem.java#L134">Java on-premise metadata</a>
- <a href="https://github.com/51Degrees/device-detection-dotnet/blob/master/Examples/OnPremise/Metadata-Console/Program.cs#L126">.NET on-premise metadata</a></p>
<h2 id="tacnative-key-lookup">TAC/Native key lookup</h2>
<p>A user wishes to get details of devices matching a
specific <a href="https://en.wikipedia.org/wiki/Type_Allocation_Code">TAC</a> or native
key.</p>
<pre><code class="language-c#">var cloudEngine = cloudAspectEngineBuilder.Build(resourceKey);
var hardwareProfileEngine = hardwareProfileCloudEngineBuilder.Build();
var pipeline = pipelineBuilder()
  .AddElement(cloudEngine)
  .AddElement(hardwareProfileEngine)
  .Build();

using(var flowdata = pipeline.CreateFlowData())
{
  flowdata.AddEvidence(Constants.TAC_KEY, tacValue);
  flowdata.Process();

  var profiles = flowData.GetFromElement(hardwareProfileEngine).Profiles.Value;
  foreach(var profile in profiles)
  {
    var hardwareName = profile.HardwareName.Value;
  }
}
</code></pre>
<p>For more detailed examples see:
- <a href="https://github.com/51Degrees/device-detection-dotnet/blob/master/Examples/Cloud/TAC-Console/Program.cs">.NET TAC lookup</a>
- <a href="https://github.com/51Degrees/device-detection-dotnet/blob/master/Examples/Cloud/NativeModel-Console/Program.cs">.NET native key lookup</a>
- <a href="https://github.com/51Degrees/device-detection-java/blob/master/device-detection.examples/console/src/main/java/fiftyone/devicedetection/examples/console/TacCloud.java">Java TAC lookup</a>
- <a href="https://github.com/51Degrees/device-detection-java/blob/master/device-detection.examples/console/src/main/java/fiftyone/devicedetection/examples/console/NativeModelCloud.java">Java native key lookup</a></p>

<hr/>
<h1 id="required-examples">Required Examples</h1>
<h2 id="features">Features</h2>
<p>It is recommended that the following features are demonstrated in examples:</p>
<ul>
<li>On-Premise Device Detection</li>
<li>Cloud Device Detection</li>
<li>Native Key/TAC Detection</li>
<li>Build from Configuration</li>
<li>Use of Fluent Builder</li>
<li>Need for Resource Key for Cloud</li>
<li>Creation of Pipeline once only</li>
<li>Presentation of Evidence</li>
<li>Access to Properties strongly typed</li>
<li>Need to dispose every Flow Data</li>
<li>Match Metrics</li>
<li>Use of Web Integration</li>
<li>Use of Client Side detection</li>
<li>Obtaining &ldquo;high entropy&rdquo; Evidence</li>
<li>Offline Processing</li>
<li>Data Update</li>
</ul>
<p>The examples in the reference implementations demonstrate combinations of the
above features - see <a href="#concrete-examples">Concrete Examples</a>.</p>
<h2 id="implementation-notes">Implementation Notes</h2>
<h3 id="execution">Execution</h3>
<p>It is recommended that examples are simply executable from an IDE, so
examples should be runnable in such a context.</p>
<p>It is recommended that unit tests be provided for examples, to verify that
the example remains valid though various code changes. Since examples
are primarily concerned with providing visual output at the time of execution
it is often difficult to carry out verification of the results produced by the
example, and it is likely to be sufficient for a test to show that the example
runs and completes without failure.</p>
<p>The need for examples to be runnable as an application and as a test suggests
that they are written with example code to be executed as a public method, and
a pattern may be established across examples.</p>
<h3 id="legibility">Legibility</h3>
<p>It is of importance for examples to illustrate key features of the APIs
in a simple way. For this reason, reference implementations use a number of
helper functions to simplify the code so as not to obscure the points
being illustrated. In creating the examples, 51Degrees found that there is a
trade-off between helper functions hiding unimportant details, and helper
functions hiding awkwardness of access to certain features.</p>
<p>Implementors may wish to consider adding those helper functions to their
API implementations, rather than them being accessible only in the
context of examples.</p>
<p>Some examples of helpers in the latter category:
- a helper that creates a hash Engine to provide access to the data file
metadata (date and data tier).
- a helper that gets the value of a Property as a string, taking into account
that a value may not exist or that it may be a list.</p>
<h3 id="code-comments">Code Comments</h3>
<p>We recommend extremely verbose and pedagogic comments as a module header and in
the code of examples.</p>
<p>51Degrees generates Web documentation (<a href="https://51degrees.com/documentation/_examples__device_detection__getting_started__console__on_premise.html">for example</a>)
from reference implementation examples, using Doxygen. For the sake of
readability of the source of the examples text intended for Doxygen
generation is placed at the bottom of source files.</p>
<h3 id="file-references">File References</h3>
<p>Finding a path to files used by examples may not be completely straightforward, as
the example may have been downloaded from GitHub, or if it&rsquo;s part of
the standard distribution of the API files, it may appear at different relative paths
to the current working directory when the example is executed - especially
when executed as an automated test as opposed to being run from an IDE.</p>
<p>In the Java reference implementation the
<a href="https://github.com/51Degrees/pipeline-java/blob/master/pipeline.core/src/main/java/fiftyone/pipeline/util/FileFinder.java">FileFinder utility</a>
is used to locate the file.</p>
<h3 id="test-data">Test Data</h3>
<p>Many examples require test data consisting of HTTP Header Evidence - User Agent
and UserAgent Client Hints. A YAML file containing 20,000 sets of such Evidence
is distributed as one of the Git submodules referenced from on-premise Hash
detection. It is also available in a repository in
<a href="https://github.com/51Degrees/device-detection-data">GitHub</a>
where it is updated on a monthly basis.</p>
<p>See <a href="#file-references">File References</a> for a discussion of locating files.</p>
<h3 id="on-premise-device-detection">On-Premise Device Detection</h3>
<p>Reference implementation examples illustrate use of the Lite Data File that is
distributed as one of the Git submodules referenced from on-premise Hash detection.
It is also updated in <a href="https://github.com/51Degrees/device-detection-data">GitHub</a>
on a monthly basis.</p>
<p>See <a href="#file-references">File References</a> for a discussion of locating files.</p>
<p>In the reference implementations it is stressed in comments as well as
in the output of examples that
the Lite data file has a small number of Properties.</p>
<p>The production date of the file in use is noted and a warning reported
if it is more than 28 days old. This serves also to illustrate how to
find the production date of the file.</p>
<h3 id="cloud-device-detection">Cloud Device Detection</h3>
<p>Reference implementation examples illustrate use of Resource Keys to access
the cloud service. A predefined link <a href="https://configure.51degrees.com/jqz435Nc">such as</a>
can be created to create a Resource Key to provide access to the Properties
used in the examples. For simplicity, it may be convenient for such a link to
provide access to all free Properties.</p>
<p>Since the Resource Key is shared between several examples, it may be convenient
for it to be set as an environment variable, rather than passing as a command
argument, especially given the need for examples to be executed in
a test environment.</p>
<h3 id="fluent-builders">Fluent Builders</h3>
<p>Reference implementation examples demonstrate the use of the simplified
top-level builder for cloud and on-premise. Noting that <a href="../../pipeline-specification/reference-implementation-notes.md">elsewhere</a>
we recommend considering the trade-off between the apparent simplicity of this
approach and some disadvantages.</p>
<p>Additionally, assuming default values are needed
this does simplify the examples. However, it has the disadvantage that users
may not understand how to use the Pipeline builder and the various Engine
builders in concert, and hence may not be aware of how they can configure
Properties that are not exposed by the simplified builder, should they need to.</p>
<p>It is recommended that at least one example demonstrates this technique for
creating a Pipeline and that it is made clear that the lifetime of the
FlowElements added to the Pipeline should, in general, be controlled by
the Pipeline
they are added to (<code>setAutoClose(true)</code>). In other words, destruction of the
Pipeline causes the elements added to it to be destroyed.</p>
<p>It is recommended that examples make reference to the options available
and their default values in a Git submodule (and see below regarding an
example XML options file containing the same information as an XML comment).
<span style="color:yellow">reference that submodule in GitHub</span></p>
<h3 id="build-from-configuration">Build from Configuration</h3>
<p>Reference implementation examples include illustration of creating a Pipeline
from a configuration file. In XML, this configuration file can be used to add,
as a comment, a listing of all the possible options for the Pipeline and all
Engines. This information is also available in a Git submodule
<span style="color:yellow">reference that submodule in GitHub</span>.</p>
<h3 id="pipeline-and-flow-data-lifecycle">Pipeline and Flow Data Lifecycle</h3>
<p>Some 51Degrees support queries relate to user confusion over the intended
lifecycle of a Pipeline and Flow Data created from it.</p>
<p>It&rsquo;s important to emphasize, in examples, that only one Pipeline is usually
required in any implementation and that it can be created as a singleton,
whose lifetime is often the same as the application that it is in.</p>
<p>Nevertheless, it is suggested that this lifetime be illustrated using the
equivalent of a &ldquo;try-with-resources&rdquo; construct, within which the Pipeline
instance is used as a factory for many Flow Data instances.</p>
<p>Similarly, but for a contrasting purpose, it is suggested that use of a
Pipeline as such a factory, using
its <code>createFlowData</code> method, is also illustrated with the call to that method
being part of a &ldquo;try-with-resources&rdquo; construct.</p>
<h3 id="shareusage">ShareUsage</h3>
<p>Since Evidence used in examples is already collected by 51Degrees there is
no value in sharing those values with 51Degrees. In addition, though use of
examples is likely to be statistically insignificant, it may nonetheless alter
the calculations that are performed regarding current usage.</p>
<p>For somewhat arbitrary reasons, reference implementations inhibit usage
sharing for console examples, but enable it for web examples. Every example in
which share usage is inhibited needs to have a comment saying that in normal
operation it should not be, which diminishes the clarity of the example.</p>
<h2 id="concrete-examples">Concrete Examples</h2>
<p>These examples are provided in the reference implementations to illustrate
<a href="#features">features</a> mentioned.</p>
<h3 id="getting-started-console">Getting Started Console</h3>
<p>Examples should be provided that illustrate basic usage of the API for
both Cloud and On-Prem, using fluent builder and options file configuration,
when executed as a console application.</p>
<p>Detailed inline comments in these examples introduce the use of Evidence and
retrieval of Properties resulting from detection, as well as illustrating
correct <a href="#pipeline-and-flowdata-lifecycle">lifecycle management</a> of Pipeline
and Flow Data instances.</p>
<p>See documentation
<a href="https://51degrees.com/documentation/_examples__device_detection__getting_started__console__cloud.html">cloud</a>,
<a href="https://51degrees.com/documentation/_examples__device_detection__getting_started__console__on_premise.html">on-premise</a></p>
<h3 id="getting-started-web">Getting Started Web</h3>
<p>These examples illustrate use of
<a href="../../pipeline-specification/features/web-integration.md">Web integration</a>
for both Cloud and On-Premise
by creating a Web page that can be accessed from a web server running in
the example environment that is created during execution of the example.</p>
<p>The example also illustrates the availability of Device Detection Properties
from client-side JavaScript as well as illustrating use of JavaScript
to collect Evidence directly from the client and present it to the server.</p>
<p>The example should illustrate various techniques for obtaining &ldquo;high entropy
values&rdquo; for presentation to the origin server as well as to the 51degrees
cloud service. See <a href="https://51degrees.com/blog/implementing-user-agent-client-hints">Implementing User Agent Client Hints</a>.</p>
<p>There is a wide choice of server-side Web frameworks, the reference
implementations illustrate basic ASP.NET Core and ASP.NET Framework usage for
C# and basic Servlet usage in Java.</p>
<p>See documentation
<a href="https://51degrees.com/documentation/_examples__device_detection__getting_started__web__cloud.html">cloud</a>,
<a href="https://51degrees.com/documentation/_examples__device_detection__getting_started__web__on_premise.html">on-premise</a></p>
<h3 id="tac-native-key-lookup">TAC / Native Key Lookup</h3>
<p>These examples illustrate retrieval of device data from the cloud service
using either TAC or native model name.</p>
<p>These examples require the user to obtain a license key in order to
configure an appropriate Resource Key.</p>
<p>See documentation
<a href="https://51degrees.com/documentation/_examples__device_detection__tac_lookup__cloud.html">TAC</a>,
<a href="https://51degrees.com/documentation/_examples__device_detection__native_key_lookup__cloud.html">Native key</a></p>
<h3 id="match-metrics">Match Metrics</h3>
<p>On-premise detection provides access to various metrics that provide insight
into the detection process and confidence in the output. A key point of this
example is to illustrate that reducing the number of Properties requested
can reduce the time for detection.</p>
<p><a href="https://51degrees.com/documentation/_examples__device_detection__match_metrics__on_premise_hash.html">See documentation</a></p>
<h3 id="metadata">Metadata</h3>
<p>It is recommended that implementors illustrate the retrieval of Evidence keys,
Properties, components and profiles from the on-premise, and
Properties and Evidence keys for cloud.</p>
<p>See documentation <a href="https://51degrees.com/documentation/_examples__device_detection__metadata__on_premise_hash.html">on-premise</a>,
<a href="https://51degrees.com/documentation/_examples__device_detection__metadata__cloud.html">cloud</a>.</p>
<h3 id="performance-options">Performance Options</h3>
<p>Reference implementations contain an &ldquo;Offline Processing&rdquo; example which
illustrates the processing of a batch file. The example also shows the
various performance options available (Low Memory, Predictive Graph, etc.)
which are commented out in the example.</p>
<p>Implementors might consider illustrating the differences between the various
combinations of options.</p>
<p><a href="https://51degrees.com/documentation/_examples__device_detection__offline_processing__on_premise_hash.html">See documentation</a></p>
<h3 id="performance-benchmark">Performance Benchmark</h3>
<p>Reference implementations contain a Performance Benchmark which is somewhat
similar to the <a href="#performance-options">&ldquo;Offline Processing&rdquo; example</a>.</p>
<p><a href="https://51degrees.com/documentation/_examples__device_detection__performance__on_premise_hash.html">See documentation</a>
Java tab.</p>
<h3 id="data-update">Data Update</h3>
<p>Examples should illustrate updating an on-premise data source both by
access to remote servers and by direct update of a file store location.</p>
<p>The data update service has a range of options available. Implementors
should illustrate:</p>
<ul>
<li>file system watcher</li>
<li>remote update polling</li>
<li>update on start-up</li>
<li>programmatic (non-automatic) update</li>
</ul>
<p><a href="https://51degrees.com/documentation/_examples__device_detection__data_file_updates__automatic.html">See documentation</a></p>

<hr/>
<h1 id="automated-testing">Automated Testing</h1>
<p>Device Detection automated testing follows the guidelines set out
in <a href="../../pipeline-specification/part3/automated-testing.md">Pipeline Automated Testing</a>
and the general comments made there are not usually repeated here.</p>
<h2 id="device-detection-cloud-engine">Device Detection Cloud Engine</h2>
<p>Testing of several
parts of the operation of the Cloud Engine may require access to a
remote server and hence the tests may appear more as integration tests
than unit tests.</p>
<p>The Java reference implementation doesn&rsquo;t provide a stub server and doesn&rsquo;t
approach testing by processing of canonical JSON examples, so does require
a remote server. Some parts of testing are carried out using mocks.</p>
<ul>
<li>Test for correct return of values with known Resource Key</li>
<li>Test for correct operation when Resource Key doesn&rsquo;t contain correct Properties</li>
<li>Test for correct operation on transient network failure</li>
</ul>
<p>General tests
- Test for correct operation when data is not available in this tier
- Test for availability of typed getters for Properties
- Test for correct operation of Evidence keys</p>
<h2 id="device-detection-on-premise-engine">Device Detection On-premise Engine</h2>
<p>Carry out similar tests to Cloud Engine, in addition
- Test for correct operation of SWIG
- Test for correct operation of performance configuration
- Test for correct operation of data tier</p>
<h2 id="examples">Examples</h2>
<p>Testing of examples is strongly recommended, at least to assess whether they
compile and can be run. It&rsquo;s usually not practical to assess the correctness
of any output from tests of examples.</p>

<hr/>
<h1 id="ua-ch-high-entropy-decoder">UA-CH high entropy decoder</h1>
<h2 id="overview">Overview</h2>
<p>This Element is part of the system that allows Device Detection to use
values from the User-Agent Client Hints (UA-CH) JavaScript API rather
that the UA-CH HTTP headers.</p>
<p>51Degrees has <a href="https://51degrees.com/blog/implementing-user-agent-client-hints">blogs</a>
and <a href="https://51degrees.com/documentation/_device_detection__features__u_a_c_h__javascript.html">documentation</a>
with more information on this.</p>
<p>The Device Detection Engines will only work if Evidence values are provided
in the same format as UA-CH HTTP headers. The Evidence values that are
collected from the UA-CH JavaScript API are in a different format and are
encoded using base-64 encoding. This element decodes and transforms this
Evidence into values that match the HTTP header format so that it can
be used by the Device Detection Engines.</p>
<h2 id="accepted-evidence">Accepted Evidence</h2>
<ul>
<li>cookie.51d_gethighentropyvalues</li>
<li>query.51d_gethighentropyvalues</li>
</ul>
<h2 id="element-data">Element Data</h2>
<p>This Element is only implemented for
<a href="https://github.com/51Degrees/device-detection-dotnet/blob/master/FiftyOne.DeviceDetection/FiftyOne.DeviceDetection/Uach/UachJsConversionElement.cs">.NET</a>
at time of writing.
The reference implementation writes to directly to Evidence, which will not
be possible if Evidence is immutable.
Instead, the Element can output its values using Element Data as described
in the table below.
The Device Detection Engines MUST be capable of using these values if
available and falling back to Evidence values if they are not.
See <a href="../../../pipeline-specification/features/evidence.md#adding-evidence-values">adding Evidence values</a>
for more details.</p>
<table>
<thead>
<tr><th> <strong>Name</strong>                    </th><th> <strong>Type</strong> </th><th> <strong>Description</strong>                                                                                 </th></tr>
</thead>
<tbody>
<tr><td> sec-ch-ua                   </td><td> string   </td><td> The value of the <code>sec-ch-ua</code> HTTP header determined from the encoded Evidence                   </td></tr>
<tr><td> sec-ch-ua-full-version-list </td><td> string   </td><td> The value of the <code>sec-ch-ua-full-version-list</code> HTTP header determined from the encoded Evidence </td></tr>
<tr><td> sec-ch-ua-model             </td><td> string   </td><td> The value of the <code>sec-ch-ua-model</code> HTTP header determined from the encoded Evidence             </td></tr>
<tr><td> sec-ch-ua-mobile            </td><td> string   </td><td> The value of the <code>sec-ch-ua-mobile</code> HTTP header determined from the encoded Evidence            </td></tr>
<tr><td> sec-ch-ua-platform          </td><td> string   </td><td> The value of the <code>sec-ch-ua-platform</code> HTTP header determined from the encoded Evidence          </td></tr>
<tr><td> sec-ch-ua-platform-version  </td><td> string   </td><td> The value of the <code>sec-ch-ua-platform-version</code> HTTP header determined from the encoded Evidence  </td></tr>
</tbody>
</table>
<h2 id="process">Process</h2>
<ul>
<li>Get the encoded value from Evidence for the <a href="#accepted-evidence">relevant keys</a></li>
<li>Use the value with the <code>query</code> prefix if both are available</li>
<li>Decode the value from base 64</li>
<li>Convert the JSON representation into individual HTTP header values.</li>
<li>See <a href="https://github.com/51Degrees/sua-uach-conversion/blob/main/src/convertSUAtoUACH.js">here</a>
for an example of this using JavaScript.</li>
</ul>
<h2 id="configuration-options">Configuration options</h2>
<p>This Element has no configuration options</p>

<hr/>
<h1 id="builder">Builder</h1>
<h2 id="sample-configuration">Sample configuration</h2>
<h1 id="engine">Engine</h1>

<hr/>
<h1 id="device-detection-cloud">Device Detection cloud</h1>
<h2 id="overview">Overview</h2>
<p>Cloud Device Detection presents <a href="../../pipeline-specification/features/evidence.md">Evidence</a>
to the 51Degrees Cloud Detection server, which carries out the detection
and returns a JSON data structure, from which Device Detection Properties
are populated in the <strong>Flow Data</strong>.</p>
<p>This is implemented as a two-step process: a Cloud Request Engine
presents the Evidence to the 51Degrees server with an HTTP request
and copies the JSON response into Element Data in the Flow Data.</p>
<p>This Element Data is passed using the standard Pipeline Flow Data mechanism to
a Device Detection Cloud Engine, later in the Pipeline. Since the detection
Engine depends on the request having been processed in advance, it checks that
Element Data from the cloud request is present in Pipeline before processing.</p>
<p><img src="../../pipeline-specification/images/Device%20Detection%20Cloud%20Engine.png" alt="Cloud Engine flow" /></p>
<p>The majority of the logic that must be performed by the Device Detection Cloud
Engine is common to all Cloud Engines and is described in the
<a href="../../pipeline-specification/pipeline-elements/cloud-aspect-engine.md">Cloud Aspect Engine</a>
document.</p>
<h2 id="device-detection-cloud-engine-configuration">Device Detection Cloud Engine configuration</h2>
<p>There are no configuration options associated with this Engine.</p>
<h2 id="device-detection-cloud-engine-processing">Device Detection Cloud Engine processing</h2>
<p>When it is added to a Pipeline, Device Detection Cloud Engine initializes
itself from a Cloud Request Engine, which must have been added to the Pipeline
before it.</p>
<p>The Cloud Request Engine determines which Properties are available
based on the Resource Key supplied on start-up. The Device Detection Cloud Engine
then takes the details of the subset of those Properties that are relevant to
Device Detection.</p>
<p>See <a href="../../pipeline-specification/pipeline-elements/cloud-request-engine.md">Cloud Request Engine</a>
for more details of this Engine.</p>

<hr/>
<h1 id="device-detection-on-premise">Device Detection on-premise</h1>
<h2 id="overview">Overview</h2>
<p>This Engine provides Device Detection capabilities using a high performance
on-premise algorithm we refer to as the
<a href="http://51degrees.com/documentation/_device_detection__hash.html">hash</a>
algorithm.</p>
<p>This Engine also requires a hash data file, which comes in three variations:</p>
<ul>
<li><strong>Lite</strong> - Freely available from <a href="https://github.com/51Degrees/device-detection-data">GitHub</a>.
Contains a highly restricted set of Properties and is updated
around once per month.</li>
<li><strong>Enterprise</strong> - Downloaded from
<a href="http://51degrees.com/documentation/_info__distributor.html">Distributor</a>.
Requires a license key for download and is usually updated Monday-Thursday. Includes all
Properties except TAC.</li>
<li><strong>TAC</strong> - Same as enterprise except that TAC is included in the result.</li>
</ul>
<h2 id="native-component">Native component</h2>
<p>In all languages, the on-premise Device Detection Engine passes the actual
detection processing to a native DLL/so library that is written in C/C++.</p>
<p>The intention was that this will ensure the best performance for the most
computationally complex part of the process and reduce maintenance overhead,
as well as the time required to add support for Device Detection in a new
language.</p>
<p>The code for this component is available on GitHub:</p>
<ul>
<li><a href="https://github.com/51Degrees/common-cxx">common-cxx</a></li>
<li><a href="https://github.com/51Degrees/device-detection-cxx">device-detection-cxx</a></li>
</ul>
<p>Unfortunately, while calling a native library is possible in many languages, it
is often fiddly and may come with unexpected difficulties. As such, we generally
use <a href="https://www.swig.org/">SWIG</a> to help produce a wrapper for the target
language. This takes care of the marshalling of data structures to and from
C data structures but represents a performance overhead - see
<a href="#performance-guidance">Performance Guidance</a> below.</p>
<p>The C library is distributed in binary form for a restricted set of target
environments <a href="https://51degrees.com/documentation/_info__tested_versions.html">tested versions</a>,
with a number of assumptions about the availability
of <a href="https://51degrees.com/documentation/_info__dependencies.html">dependencies</a>.</p>
<h3 id="selecting-the-correct-binary">Selecting the correct binary</h3>
<p>While the implementor is not expected to produce the CI/CD scripts that
will create the final packages, attention must be given to how the final
package will determine the correct native binary to use based on the current
operating system.</p>
<p>In some cases, this capability is built into the packaging infrastructure
(For example, .NET/NuGet). Some require additional code to be written to
determine the correct binary at runtime (Java/Maven and Node/NPM). Others
do not allow native binaries in packages at all (PHP/Composer).</p>
<h3 id="reference-implementation-notes">Reference implementation notes</h3>
<p>The reference implementations bundle the cxx code in with the Java/.NET
code and build it all together. This works well enough, but does come
with the downside of adding significant complexity to the build process
for customers who may just be able to consume pre-built native binaries.</p>
<p>For future implementations, we recommend exploring the possibility of
moving the native binary and target language wrapper to a separate
repository and package from the target language Device Detection Engine
logic.</p>
<h2 id="accepted-evidence">Accepted Evidence</h2>
<p>This Engine determines the accepted Evidence keys on data refresh based
on values in the data source.</p>
<p>After loading the data source into the native code, call the <code>getKeys</code>
function to return a list of the accepted Evidence keys.
These values should then be stored to prevent repeated calls to the
native code.</p>
<p>This must be done at start-up and any time the data is refreshed.</p>
<p>Note that the list of accepted Evidence keys is not case-sensitive -
i.e. <code>header.user-agent</code> and <code>header.User-Agent</code> should both be
accepted.</p>
<h2 id="element-data">Element Data</h2>
<p>The list of Properties that can be populated by this Engine is determined
on data refresh based on the Properties that are available in the data
source that is used.</p>
<p>In addition, several additional <a href="#match-metric-properties">match metrics</a>
Properties must be added as well. The table below shows the native
function to call to get the value for each Property.</p>
<table>
<thead>
<tr><th> Name         </th><th> Function on result object to call to get value [^nb] </th></tr>
</thead>
<tbody>
<tr><td> MatchedNodes </td><td> getMatchedNodes                                      </td></tr>
<tr><td> Difference   </td><td> getDifference                                        </td></tr>
<tr><td> Drift        </td><td> getDrift                                             </td></tr>
<tr><td> DeviceId     </td><td> getDeviceId                                          </td></tr>
<tr><td> UserAgents   </td><td> getUserAgents                                        </td></tr>
<tr><td> Iterations   </td><td> getIterations                                        </td></tr>
<tr><td> Method       </td><td> getMethod                                            </td></tr>
</tbody>
</table>
<p>[^nb] Note that the native implementations have some additional complexity
in their code because of a plan to split Device Detection into 4
separate Engines. This is not necessary in new implementations.</p>
<p>It is essential that the <strong>Element Data</strong> instance populated by this
On-premise Engine is interface compatible with the <strong>Element Data</strong>
populated by the <a href="device-detection-cloud.md">cloud Device Detection Engine</a>
as well as the individual devices populated in the <strong>Element Data</strong> from
the <a href="hardware-profile-lookup-cloud.md">hardware profile lookup Engine</a>.</p>
<h2 id="start-up-activity">Start-up activity</h2>
<p>On start-up, the native Engine needs to be created using the data file.
Several functions must then be called to get the data that will be needed
by other Engine features.</p>
<p>See <a href="#refresh-data">refresh data</a> for details on this process.</p>
<h2 id="processing">Processing</h2>
<p>This section describes the core steps this Engine executes to process
<strong>Flow Data</strong>. This is on top of any common processing defined for
other Pipeline API features.</p>
<ul>
<li>Create and populate the native Evidence object</li>
<li>The Evidence values will typically need to be converted to a memory
format that can be used by the native Cxx code.</li>
<li>First, create a new <code>EvidenceDeviceDetection</code> C++ instance.</li>
<li>Next, add items from the <strong>Flow Data</strong> Evidence to the C++ instance.
<ul>
<li>Only need to add entries that the Engine will make use of.</li>
</ul>
</li>
<li>Call the <code>process</code> function on the native Engine, passing the native
Evidence instance.</li>
<li>This will return a <code>ResultsHash</code> instance, which contains references to
the resulting Property values.</li>
<li>Create a new instance of the implementation of the <code>IDeviceData</code> interface
that is being used for the On-premise Engine.</li>
<li>Pass the <code>ResultsHash</code> instance so it can be used when Property values
are requested.</li>
<li>Do not immediately copy all the Property values from <code>ResultsHash</code>. By
default, around 200 Properties will be populated, meaning 200+ calls to
the native code marshalling values back and forth [^caching].</li>
</ul>
<p>[^caching] Note the effect that
holding the &ldquo;unmanaged&rdquo; memory references (i.e. memory references that
are not handled by language garbage collection) has on
<a href="../../pipeline-specification/features/caching.md">caching</a> and
<a href="../../pipeline-specification/features/resource-cleanup.md">resource cleanup</a>.
The reference implementations don&rsquo;t allow a cache to be
added to this Engine because of the complexity this introduces, however
end-users may be tempted to create their own cache of results.</p>
<h3 id="performance-guidance">Performance guidance</h3>
<p>We have found that the main performance bottleneck is usually the process
of marshalling data values to and from native representations.</p>
<p>As such, this should be minimized as much as possible:</p>
<ul>
<li>Languages often have many mechanisms for passing data in calls
to native binaries, some more efficient than others. SWIG code will
sometimes use the most flexible approach, rather than the most performant.
It is worth checking the generated code for relatively easy performance
wins.</li>
<li>Whenever making a call to native code, be aware of the data that is being
passed and check if there is anything that can be done to reduce it.</li>
<li>Finally, do not call native code at all if it can be avoided. For example, any
values that will only change after a <a href="#refresh-data">data refresh</a> should
be stored in the Engine instance to avoid native calls for that value until
a refresh occurs. Not the possible clean-up consequences that this implies.</li>
</ul>
<h2 id="refresh-data">Refresh data</h2>
<p>The <a href="../../pipeline-specification/features/data-updates.md#aspect-engine-features">refresh data function</a>
for this Engine must perform the following tasks:
- Create a new instance of the C++ <code>EngineHashSwig</code> type using either the
filename or byte[] constructor.
- Call <code>refreshData</code> on the C++ Engine in order to load data into the
relevant data structures.
- Call the necessary functions on the C++ Engine in order to acquire
metadata about the Engine that is dependent on the data file:
- <a href="#accepted-evidence">accepted Evidence</a>
- <a href="#property">Properties</a>
- <a href="#metadata">additional Device Detection metadata</a>
- data file publish date
- expected publish date of next data file
- data file type
- data file temp path</p>
<p>The following table lists the C++ Engine functions to call to get the data
mentioned above:</p>
<table>
<thead>
<tr><th> Function name            </th><th> Notes                                                                                                                                                                                              </th></tr>
</thead>
<tbody>
<tr><td> <code>getKeys</code>                </td><td> Get a list of the Evidence keys that the data file will make use of                                                                                                                                </td></tr>
<tr><td> <code>getMetaData</code>            </td><td> Get <a href="#metadata">metadata</a> from the data file                                                                                                                                                      </td></tr>
<tr><td> <code>getPublishedTime</code>       </td><td> Get the date/time that the data file was created                                                                                                                                                   </td></tr>
<tr><td> <code>getUpdateAvailableTime</code> </td><td> Get the data/time that a new data file is expected to be available                                                                                                                                 </td></tr>
<tr><td> <code>getProduct</code>             </td><td> Get the string type of the data file. This is used by the <a href="../../pipeline-specification/features/data-updates.md">data update</a> functionality when calling Distributor to check for a new data file </td></tr>
<tr><td> <code>getDataFileTempPath</code>    </td><td> Get the path to the temporary working copy of the data file (This is the full path to the copy of the data file that the C code makes before reading it.)                                          </td></tr>
</tbody>
</table>
<h2 id="events">Events</h2>
<p>This Engine should implement the following events/callbacks/hooks:</p>
<table>
<thead>
<tr><th> Name             </th><th> Notes                                                                       </th></tr>
</thead>
<tbody>
<tr><td> Refresh complete </td><td> Used by client to perform some action after a new data file has been loaded </td></tr>
</tbody>
</table>
<h2 id="metadata">Metadata</h2>
<h3 id="overview">Overview</h3>
<p>On-premise Device Detection has two related metadata structures:
1. The Device Detection data file includes metadata relating to the structure of the
values that are stored in the file. This is exposed by the Device Detection Engine
in order to allow users to query the data. [^performance]
2. All Flow Elements expose a list of metadata relating to Properties populated by
that element. In the case of the Device Detection Engine, this list will include
Property metadata derived from the data file metadata mentioned above.</p>
<p>[^performance] Note that, due to the structure of the data, this is not intended to support
high-performance querying scenarios. For that use-case, customers are directed to our
&lsquo;csv&rsquo; data file, which can be consumed and stored in a database or whatever other form
is required for querying.</p>
<pre><code class="language-mermaid">erDiagram
    Component ||--|{ Property : has
    Property ||--|{ Value : has
    Component ||--|{ Profile : has
    Profile ||--|{ Value : has
</code></pre>
<h3 id="component">Component</h3>
<p>A <strong>component</strong> defines a group of <strong>Properties</strong> that are related.</p>
<p>In a 51Degrees data set, each <strong>Property</strong> can only be related to one <strong>component</strong>.
For example, the <code>Browser Name</code> <strong>Property</strong> is part of the <code>Software</code> <strong>component</strong>,
whereas the <code>Model Name</code> <strong>Property</strong> is part of the <code>Hardware</code> <strong>component</strong>.</p>
<p>The metadata associated with a <strong>component</strong> is:</p>
<table>
<thead>
<tr><th> Metadata        </th><th> Description                                                                                                                                                                         </th></tr>
</thead>
<tbody>
<tr><td> Id              </td><td> The unique id of the <strong>component</strong>. This is a number and will remain the same when a data file is updated.                                                                          </td></tr>
<tr><td> Name            </td><td> The name of the <strong>component</strong> that gives a more &lsquo;human&rsquo; identifier than id. By convention, this is unique within the data file.                                                     </td></tr>
<tr><td> Default profile </td><td> The default <strong>profile</strong> for the <strong>component</strong>. This is used to provide <strong>values</strong> for the <strong>component&rsquo;s</strong> <strong>Properties</strong> when a <strong>profile</strong> matching the @Evidence cannot be found. </td></tr>
<tr><td> Properties      </td><td> The <strong>Properties</strong> associated with this <strong>component</strong>.                                                                                                                              </td></tr>
</tbody>
</table>
<h3 id="property">Property</h3>
<p>The <strong>Properties</strong> exposed by the Device Detection Engine contain more information
than that which is defined by the standard <strong>Property metadata</strong> interface.
In addition to the usual information, the following must be made available:</p>
<table>
<thead>
<tr><th> Metadata      </th><th> Description                                                                                                                                                                                                                                                  </th></tr>
</thead>
<tbody>
<tr><td> Description   </td><td> A description of the <strong>Property</strong> explaining what it refers to, and what significance its values have.                                                                                                                                                       </td></tr>
<tr><td> URL           </td><td> A URL where more information on the <strong>Property</strong> can be found.                                                                                                                                                                                               </td></tr>
<tr><td> Component     </td><td> The <strong>component</strong> to which the <strong>Property</strong> belongs. This is subtly different from the category, in that a <strong>profile</strong> defines the values for all the <strong>Properties</strong> of a single <strong>component</strong>, which likely contains multiple categories of <strong>Properties</strong>. </td></tr>
<tr><td> Values        </td><td> The <strong>values</strong> that the <strong>Property</strong> can have. As a simple example, a <strong>Property</strong> named <code>'IsSmartPhone'</code> might have three values: <code>true</code>, <code>false</code>, and <code>unknown</code>.                                                                                   </td></tr>
<tr><td> Default Value </td><td> The default <strong>value</strong> for the <strong>Property</strong> if it is not otherwise known. In the above example, the <strong>Property</strong> named <code>'IsSmartPhone'</code> would probably have <code>unknown</code> as the default value.                                                               </td></tr>
<tr><td> List          </td><td> Whether or not the <strong>Property</strong> may have multiple values. For example, the connectivity types a device supports would be a list, as a single device might support Bluetooth, HSDPA, LTE, Wi-Fi, etc.                                                         </td></tr>
<tr><td> Obsolete      </td><td> Whether the <strong>Property</strong> is obsolete and only exists to maintain backward compatibility.                                                                                                                                                                     </td></tr>
<tr><td> Display Order </td><td> The suggested order in which to display the <strong>Property</strong> when listing <strong>Properties</strong>.                                                                                                                                                                        </td></tr>
<tr><td> Mandatory     </td><td> Whether the <strong>Property</strong> is mandatory or not. If a <strong>Property</strong> is mandatory, a <strong>profile</strong> must have a non-default value for it to be classed as valid.                                                                                                     </td></tr>
<tr><td> Show          </td><td> Whether the <strong>Property</strong> should be displayed in situations such as a page listing <strong>Properties</strong>. Less important <strong>Properties</strong> may not be displayed.                                                                                                        </td></tr>
<tr><td> Show Values   </td><td> Whether values of the <strong>Property</strong> should be displayed in situations such as a page listing the <strong>Property&rsquo;s</strong> values. Showing all the values can make a very long list.                                                                                     </td></tr>
</tbody>
</table>
<h3 id="profile">Profile</h3>
<p>A <strong>profile</strong> defines a unique set of <strong>values</strong> for all <strong>Properties</strong> of
a single <strong>component</strong>.</p>
<table>
<thead>
<tr><th> Metadata  </th><th> Description                                                                                                                                                                           </th></tr>
</thead>
<tbody>
<tr><td> Id        </td><td> The unique id of the <strong>profile</strong>. This is usually a number and will remain the same when a data file is updated.                                                                      </td></tr>
<tr><td> Name      </td><td> The name of the <strong>profile</strong> that gives a more &lsquo;human&rsquo; identifier than id, usually describing what the <strong>values</strong> it contains are. By convention, this is unique within the data file. </td></tr>
<tr><td> Component </td><td> The <strong>component</strong> to which the <strong>profile</strong> relates. This is the <strong>component</strong> which the <strong>profile</strong> contains <strong>values</strong> for.                                                          </td></tr>
<tr><td> Values    </td><td> The <strong>values</strong> that define the <strong>profile</strong>.                                                                                                                                           </td></tr>
</tbody>
</table>
<h3 id="value">Value</h3>
<p>Each <strong>Property</strong> has a set of possible <strong>values</strong> that it can return.
The metadata associated with a <strong>value</strong> is:</p>
<table>
<thead>
<tr><th> Metadata    </th><th> Description                                                                                                                                                   </th></tr>
</thead>
<tbody>
<tr><td> Name        </td><td> The <strong>value</strong> as a string. This uniquely identifies the <strong>value</strong> only within the <strong>values</strong> relating to the same <strong>Property</strong>.                               </td></tr>
<tr><td> Property    </td><td> The <strong>Property</strong> to which the <strong>value</strong> relates. This, in combination with the name, uniquely identifies the <strong>value</strong> within the Device Detection data file. </td></tr>
<tr><td> Description </td><td> A description of the <strong>value</strong> explaining what it refers to, and what it means if a <strong>profile</strong> has this <strong>value</strong>.                                           </td></tr>
<tr><td> URL         </td><td> A URL where more information on the <strong>value</strong> can be found.                                                                                                   </td></tr>
</tbody>
</table>
<h3 id="match-metric-properties">Match metric Properties</h3>
<p>In addition to the &lsquo;standard&rsquo; Device Detection Properties, there are a set of
Properties that return details about the processing that was performed and
the match that was found. Metadata for these Properties must be added, as they
will not be included in the metadata exposed by the native code.</p>
<p>All these Properties have the following values:
- Category = &ldquo;Device Metrics&rdquo; (sic)
- Available With = &ldquo;Lite&rdquo;, &ldquo;Premium&rdquo;, &ldquo;Enterprise&rdquo;, &ldquo;TAC&rdquo; - If possible, this
list should be created dynamically from the lists of files included against
all other Property metadata that is exposed by the native code.
- Component = &ldquo;Metrics&rdquo; - This component must also be added to the list of
components returned by the Engine.</p>
<table>
<thead>
<tr><th> Name             </th><th> Type   </th><th> Default value </th><th> Description                                                                                                                                                                                                                                                                </th><th> Possible values                                 </th></tr>
</thead>
<tbody>
<tr><td> MatchedNodes     </td><td> int    </td><td> 0             </td><td> Indicates the number of hash nodes matched within the Evidence.                                                                                                                                                                                                            </td><td> n/a                                             </td></tr>
<tr><td> Difference       </td><td> int    </td><td> 0             </td><td> Used when detection method is not Exact or None. The larger the value the less confident the detector is in this result.                                                                                                                                                   </td><td> n/a                                             </td></tr>
<tr><td> Drift            </td><td> int    </td><td> 0             </td><td> Total difference in character positions between where the substring&rsquo;s hashes were found and where they were expected.                                                                                                                                                      </td><td> n/a                                             </td></tr>
<tr><td> DeviceId         </td><td> string </td><td> &ldquo;0-0-0-0&rdquo;     </td><td> Contains the profile ids of the matching profiles, separated by a hyphen symbol. For example [HardwareId]-[PlatformId]-[BrowserId]-[CrawlerId]. By convention, these will be in component Id order. There will often be 4 ids present, but this is not guaranteed. </td><td> n/a                                             </td></tr>
<tr><td> MatchingEvidence </td><td> string </td><td> &ldquo;n/a&rdquo;         </td><td> The matched User-Agents.                                                                                                                                                                                                                                                   </td><td> n/a                                             </td></tr>
<tr><td> Iterations       </td><td> int    </td><td> 0             </td><td> The number of iterations carried out in order to find a match. This is the number of nodes in the graph which have been visited.                                                                                                                                           </td><td> n/a                                             </td></tr>
<tr><td> Method           </td><td> string </td><td> &ldquo;NONE&rdquo;        </td><td> The method used to determine the match result.                                                                                                                                                                                                                             </td><td> &ldquo;NONE&rdquo;, &ldquo;PERFORMANCE&rdquo;, &ldquo;COMBINED&rdquo;, &ldquo;PREDICTIVE&rdquo; </td></tr>
</tbody>
</table>
<h2 id="configuration-options">Configuration options</h2>
<p>These are the configuration options that are unique to this Engine. They are in
addition to all the configuration options defined for other features. For example,
<a href="../../pipeline-specification/features/data-updates.md#configuration-groups">data updates</a></p>
<table>
<thead>
<tr><th> <strong>Parameter</strong>             </th><th> <strong>Native code location</strong>                                                                                                                            </th><th> <strong>Optional</strong> </th><th> <strong>Default</strong>                                                                                                                      </th><th> <strong>Notes</strong>                                                                                                                                                                                                                                                                                                                                                                                                   </th></tr>
</thead>
<tbody>
<tr><td> Difference                </td><td> <a href="https://github.com/51Degrees/device-detection-cxx/blob/main/src/hash/ConfigHash.hpp#L139">ConfigHash::setDifference()</a>                             </td><td> Yes          </td><td> Native code [^1]                                                                                                                 </td><td> Used to set the maximum <a href="https://51degrees.com/documentation/_device_detection__hash.html#difference">difference</a> in hash value to allow when processing HTTP headers.                                                                                                                                                                                                                                  </td></tr>
<tr><td> Drift                     </td><td> <a href="https://github.com/51Degrees/device-detection-cxx/blob/main/src/hash/ConfigHash.hpp#L147">ConfigHash::setDrift()</a>                                  </td><td> Yes          </td><td> Native code [^1]                                                                                                                 </td><td> Used to set the maximum <a href="https://51degrees.com/documentation/_device_detection__hash.html#drift">drift</a> in hash position to allow when processing HTTP headers.                                                                                                                                                                                                                                         </td></tr>
<tr><td> Allow Unmatched           </td><td> <a href="https://github.com/51Degrees/device-detection-cxx/blob/main/src/ConfigDeviceDetection.hpp#L108">ConfigDeviceDetection::setAllowUnmatched()</a>        </td><td> Yes          </td><td> Native code [^1]                                                                                                                 </td><td> If no match is found for the Evidence value then this controls how the Property values will be populated in the result.</br>If set to false, Properties will not have set values.</br>If set to true, Property values will be set from the default <a href="#profile">profile</a> for that component. This means that Properties will always have values (i.e. no need to check .HasValue) but some may be inaccurate. </td></tr>
<tr><td> Reuse Operational File    </td><td> <a href="https://github.com/51Degrees/common-cxx/blob/main/ConfigBase.hpp#L104">ConfigBase=&gt;setReuseTempFile()</a>                                             </td><td> Yes          </td><td> Native code [^1]                                                                                                                 </td><td> Set whether or not an existing operational file should be used if one is found in the temp directory.                                                                                                                                                                                                                                                                                                       </td></tr>
<tr><td> Update Matched User Agent </td><td> <a href="https://github.com/51Degrees/device-detection-cxx/blob/main/src/ConfigDeviceDetection.hpp#L91">ConfigDeviceDetection::setUpdateMatchedUserAgent()</a> </td><td> Yes          </td><td> Native code [^1]                                                                                                                 </td><td> Set whether or not the result should include the characters from the Evidence values that were used to find a match. If set, this will be available from the &lsquo;MatchingEvidence&rsquo; <a href="#match-metric-properties">match metric</a> Property. This is optional because it adds some overhead that is not necessary in normal operation.                                                                                </td></tr>
<tr><td> Use Performance Graph     </td><td> <a href="https://github.com/51Degrees/device-detection-cxx/blob/main/src/hash/ConfigHash.hpp#L159">ConfigHash::setUsePerformanceGraph()</a>                    </td><td> Yes          </td><td> Native code [^1]                                                                                                                 </td><td> Set whether or not to use the <a href="https://51degrees.com/documentation/_device_detection__hash.html#performance-graphs">performance</a> graph when attempting to match Evidence values.                                                                                                                                                                                                                        </td></tr>
<tr><td> Use Predictive Graph      </td><td> <a href="https://github.com/51Degrees/device-detection-cxx/blob/main/src/hash/ConfigHash.hpp#L170">ConfigHash::setUsePredictiveGraph()</a>                     </td><td> Yes          </td><td> Native code [^1]                                                                                                                 </td><td> Set whether or not to use the <a href="https://51degrees.com/documentation/_device_detection__hash.html#predictive-graphs">predictive</a> graph when attempting to match Evidence values.                                                                                                                                                                                                                          </td></tr>
<tr><td> Performance Profile       </td><td> <a href="https://github.com/51Degrees/device-detection-cxx/blob/main/src/hash/ConfigHash.hpp#L104">ConfigHash=&gt;set[ProfileName]()</a>                        </td><td> Yes          </td><td> Balanced. See <a href="https://github.com/51Degrees/device-detection-cxx/blob/master/src/hash/hash.c#L175">native code</a> for definitions. </td><td> Set the performance profile to use when creating the Engine. Each profile has default values for various internal configuration options, as well as things like the use of predictive/performance graphs.                                                                                                                                                                                                   </td></tr>
<tr><td> Concurrency               </td><td> <a href="https://github.com/51Degrees/device-detection-cxx/blob/main/src/hash/ConfigHash.hpp#L180">ConfigHash::setConcurrency()</a>                            </td><td> Yes          </td><td> System processor count                                                                                                           </td><td> Set the expected number of concurrent operations using the Engine. This is used to configure internal caches to avoid excessive locking. It has no effect if these internal caches are not used. (For example, when using the &lsquo;MaxPerformance&rsquo; profile)                                                                                                                                                     </td></tr>
</tbody>
</table>
<p>[^1]: The default values for many configuration options comes from the native
C/C++ code. You can find these defaults in the following files:
- <a href="https://github.com/51Degrees/common-cxx/blob/master/config.h">https://github.com/51Degrees/common-cxx/blob/master/config.h</a>
- <a href="https://github.com/51Degrees/device-detection-cxx/blob/master/src/config-dd.h">https://github.com/51Degrees/device-detection-cxx/blob/master/src/config-dd.h</a></p>

<hr/>
<h1 id="pipeline-specification">Pipeline specification</h1>
<h2 id="introduction">Introduction</h2>
<p>This folder structure contains a language agnostic specification for the 51Degrees
v4 Pipeline API.
We aim to avoid specific details of classes, interfaces, methods or the like. The
focus is on the behavior rather than the method by which that behavior is achieved.
This allows implementers to choose an architectural approach that is most appropriate
for the target language.</p>
<h2 id="structure">Structure</h2>
<p>This specification is broken down into separate markdown files in multiple directories.</p>
<table>
<thead>
<tr><th> Directory </th><th> Description </th></tr>
</thead>
<tbody>
<tr><td> features </td><td> Descriptions of Pipeline API features </td></tr>
<tr><td> advanced-features </td><td> Descriptions of Pipeline API features that are not implemented in all languages and/or do not have strong enough justifications for the complexity they add </td></tr>
<tr><td> Pipeline-elements </td><td> Specifications for <strong>Flow Elements</strong> that are needed to provide core functionality  </td></tr>
</tbody>
</table>
<p>If you&rsquo;re not sure where to start, read through the primer section below before
exploring further.</p>
<h2 id="description">Description</h2>
<p>51Degrees <code>Pipeline</code> provides a framework within which input data is transformed
and enriched to create output data to be consumed by some application.</p>
<p>Note that more concrete details on the terms defined here can be found in the
<a href="conceptual-overview.md">conceptual overview</a>.</p>
<h3 id="flow">Flow</h3>
<p>Processing is performed by a sequence of steps which consume the
output of earlier steps and produce output of their own. The sequence of
steps is called <em>flow</em>: the steps are called <code>Flow Elements</code> and the data
transferred between them is called <code>Flow Data</code>.</p>
<p>Flow is unidirectional and does not provide for branching and looping. Parallel
operation of steps or a sequence of steps is possible.</p>
<p>Flow Elements consume <code>Evidence</code> and may produce <code>Element Data</code>. This consists
of name-value pairs of Property values which are accessible by Property name.
There <code>Element Data</code> instances are then stored in the Flow Data. Hence, Flow
Elements may also consume <code>Element Data</code> generated earlier in the flow.
Flow Elements &ldquo;advertise&rdquo; the Evidence that they consume, the Properties that
they produce, a key for accessing those Properties from the Flow Data and various
information about the data types within which those Properties are found.</p>
<h3 id="flow-data-lifecycle">Flow Data Lifecycle</h3>
<p>Creation of Flow Data is carried out by an application requesting an instance
from a Pipeline. With a number of important exceptions, the creating
application must destroy the Flow Data once it has completed its processing.</p>
<p>The application carries out the initial population of Evidence
and then requests that the Pipeline <code>process</code> it - i.e. present the Flow Data
to the various Flow Elements that comprise it, in sequence. Processing is
synchronous by default and the application may consume Properties produced
during processing once it is complete. A Flow Data may only be processed
once and belongs to exactly one Pipeline.</p>
<p>Flow Data may also be used to report errors that occur during processing.</p>
<h3 id="engine">Engine</h3>
<p>An <code>Engine</code> is a specialization of a Flow Element, which builds on the basic
functionality provided by Flow Element to provide higher level functions
in a consistent way.</p>
<p>An <code>Aspect Engine</code> concerns itself with processing Evidence to populate
Properties related to some <em>Aspect</em> related to the received Evidence. For example,
<em>Device Detection</em> concerns itself with determining the Aspects of <em>hardware</em>,
<em>browser</em> and <em>operating system</em> determined by analysis of Evidence received
in an HTTP request, such as HTTP Headers and Cookies.</p>
<p>Engines are classed as <code>Cloud</code> Engines, which carry out their processing
by delegation to a remote server, and <code>On-Premise</code> Engines, which typically
carry out processing by reference to one or more data files, stored locally.
Facilities are available for update and installation of such data files.</p>
<p>Where both Cloud and On-Premise variants of an Engine are available, they should
arrange that the Properties and values produced are compatible with each other
so that the Engines may be substituted in the Pipeline without alteration to
the consuming application.</p>
<p>Engines may be configured with caches and offer the ability to carry out lazy
evaluation of Property values. Engine instances may be shared between Pipelines.</p>
<p><img src="images/PipelineFlow.png" alt="Illustration of Pipeline Flow" /></p>

<hr/>
<h1 id="conceptual-overview">Conceptual overview</h1>
<h2 id="core">Core</h2>
<p>The core package contains everything needed to construct a Pipeline and pass through
a Flow Data object.</p>
<h3 id="flow-data">Flow Data</h3>
<p>The <strong>Flow Data</strong> object is the fundamental unit of work within the Pipeline API.
It is primarily a container for various data sets, and is the mechanism by which
inputs are provided to the Pipeline and outputs are returned to the user.</p>
<p>The input data, or &lsquo;Evidence&rsquo; is a set of key-value pairs. For more details,
see the <a href="features/evidence.md">Evidence</a> section.</p>
<p>The output data consists of one <strong>Element Data</strong> instance for each <strong>Flow Element</strong>
in the <strong>Pipeline</strong>. These are accessed using the &lsquo;data key&rsquo; string of the
<strong>Flow Element</strong> that created each entry.</p>
<p><strong>Flow Data</strong> objects are created by a Pipeline and can only be used within the
Pipeline by which they were created. The Process method on <strong>Flow Data</strong>
initiates Pipeline processing.</p>
<p>A <strong>Flow Data</strong> belongs to exactly one <strong>Pipeline</strong>.
While a <strong>Pipeline</strong> may have many <strong>Flow Data</strong> instances.
The standard usage pattern is to create a singleton Pipeline instance that will
be used in environments such as web servers. As such, it is expected that many
<strong>Flow Data</strong> instances will be created and processed in parallel from a single
<strong>Pipeline</strong>.</p>
<p>A <strong>Pipeline</strong> does not maintain references to <strong>Flow Data</strong> instances that it
has created, but they maintain references to it.</p>
<p>See <a href="features/thread-safety.md">thread safety</a> for details on concurrent access requirements.</p>
<p><strong>Flow Data</strong> must support various different ways of accessing the data it contains.
See <a href="features/access-to-results.md">access to results</a> for more information.</p>
<h3 id="element-data">Element Data</h3>
<p><strong>Element Data</strong> is a container, within the <strong>Flow Data</strong>, for Property values
relating to a particular <strong>Flow Element</strong>. These values are set by
<strong>Flow Elements</strong> during processing. <strong>Element Data</strong> is retrieved from
<strong>Flow Data</strong> using the &lsquo;data key&rsquo; associated with the <strong>Flow Element</strong>.</p>
<p>See <a href="features/access-to-results.md">access to results</a> for more<br />
information on how this data should be accessed.</p>
<p>See <a href="features/resource-cleanup.md">resource cleanup</a> for details on ensuring
<strong>Element Data</strong> resources are cleaned up correctly.</p>
<h3 id="flow-element">Flow Element</h3>
<p>A <strong>Flow Element</strong> is a black box which takes a <strong>Flow Data</strong> and performs some
processing. This processing may read Evidence and/or <strong>Element Data</strong> instances
that have been added by previous elements. It may add new Evidence values and
may add an instance of its own Element Data, which may or may not have
Properties populated.</p>
<p>See <a href="features/resource-cleanup.md">resource cleanup</a> for details on ensuring
<strong>Flow Element</strong> resources are cleaned up correctly.</p>
<h3 id="flow-element-builder">Flow Element builder</h3>
<p>It is highly recommended that <strong>Flow Elements</strong> have some associated
builder/factory that is used to create <strong>Flow Element</strong> instances.</p>
<p>The exact specification of this component is less important than having a common
mechanism for construction of elements. This provides consistency for users and
will assist in the implementation of other parts of the specification.</p>
<p>In most languages, we have found the builder pattern to be the best approach.
However, in some languages this pattern is less common. For ease of use, we want
users to be familiar with whatever approach is used to create instances.</p>
<p>If the pattern to use is uncertain, we recommend looking at multiple high profile
and highly regarded libraries for the target language and mirroring the approach
used by them.</p>
<p>See <a href="features/pipeline-configuration.md">Pipeline configuration</a> for more
information on configuring and creating elements.</p>
<p>Be aware that the way builders were implemented in the reference languages
has caused some issues that could be avoided by making different design
decisions in future implementations. These are discussed in more detail
in <a href="reference-implementation-notes.md#builders">reference implementation notes</a></p>
<h3 id="pipeline">Pipeline</h3>
<p>A <strong>Pipeline</strong> is a method of grouping multiple <strong>Flow Elements</strong> into a single
process. By default, elements are always executed sequentially in the order
that they are added. See <a href="#pipeline-builder">Pipeline builder</a> for more details.</p>
<p>A <strong>Pipeline</strong> object is intended to be immutable. In other words, once created, it cannot be
changed by adding new elements, removing old ones, etc.</p>
<h3 id="pipeline-builder">Pipeline builder</h3>
<p>As with <a href="#flow-element-builder">Flow Elements</a>, we have found that the builder
pattern is a good way to control the creation of <strong>Pipeline</strong> instances.</p>
<p>See <a href="features/pipeline-configuration.md">Pipeline configuration</a> for more information
on configuring and creating instances.</p>
<h2 id="engines">Engines</h2>
<p>The Engines package adds features to <strong>Flow Elements</strong> that are common to
multiple different 51Degrees element implementations.</p>
<h3 id="aspect-engine">Aspect Engine</h3>
<p>See the <a href="README.md#engine">readme</a> for a definition of &lsquo;Aspect&rsquo;.</p>
<p><strong>Aspect Engines</strong> (often shortened to just &lsquo;<strong>Engines</strong>&rsquo;) are a specific type
of <strong>Flow Element</strong> with additional features and Properties:</p>
<ul>
<li><a href="features/caching.md">Results caching</a></li>
<li><a href="features/data-updates.md">Data file automatic updates</a></li>
<li><a href="features/properties.md#lazy-loading">Lazy loading</a></li>
<li><a href="features/properties.md#missing-properties">Missing Properties</a></li>
</ul>
<h3 id="aspect-data">Aspect data</h3>
<p>In the same way that <strong>Aspect Engines</strong> are specific types of <strong>Flow Element</strong>.
<strong>Aspect Data</strong> are specific types of <strong>Element Data</strong>.</p>
<p>See <a href="#aspect-engine">Aspect Engines</a> for details of the features that
<strong>Aspect Engines</strong> / <strong>Aspect Data</strong> have on top of standard <strong>Flow Element</strong> /
<strong>Element Data</strong>.</p>
<h2 id="cloud-engines">Cloud Engines</h2>
<p>The premise of Cloud Engines is to offload processing that might otherwise
be performed by an on-premise <strong>Aspect Engine</strong> to a remote service.</p>
<h3 id="cloud-request-engine">Cloud Request Engine</h3>
<p>The Cloud Request Engine is a further specialization of <strong>Aspect Engine</strong>
with the task of making requests to a remote service.</p>
<p>In theory, this could be an internally hosted service. In practice, it is
usually the <a href="https://cloud.51degrees.com/api-docs/index.html">51Degrees cloud service</a>.</p>
<p>This Engine outputs a single Property, the value of which is the JSON data
that is returned by the remote service that it calls.</p>
<p>See <a href="pipeline-elements/cloud-request-engine.md">Cloud Request Engine</a>
for the technical details.</p>
<h3 id="cloud-aspect-engine">Cloud Aspect Engine</h3>
<p>The Cloud Aspect Engine is also a specialization of <strong>Aspect Engine</strong>.
It takes the JSON result from the Cloud Request Engine and transforms
it into an <strong>Aspect Data</strong> instance that is interface compatible with
the data from the equivalent On-premise Engine.</p>
<p>See <a href="pipeline-elements/cloud-aspect-engine.md">Cloud Aspect Engine</a>
for the technical details.</p>

<hr/>
<h1 id="reference-implementation-architecture-notes">Reference implementation architecture notes</h1>
<p>This section discusses architectural Aspects of the reference implementations
(C# and Java) which were designed with extensibility in mind and to provide the basis
for possible re-use in the creation of Flow Elements and Engines.</p>
<p>It is not the intention to constrain or limit implementations to follow
the patterns listed here, indeed, in some languages such patterns are not
idiomatic or are hard to achieve. In other cases experience says that the
desirability of doing so may be in question.
However, taking advantage of the existing design may be expedient, or desirable.</p>
<h2 id="interfaces-base-classes-inheritance">Interfaces, base classes, inheritance</h2>
<p>The reference implementations follow &ldquo;classic&rdquo; Object-Oriented approach of defining
interfaces, implementing abstract base classes and creating default
implementations for the majority of features of the system.</p>
<p>Frequently, the default implementation is the only implementation, so the
strict separation of concerns represented by this approach doesn&rsquo;t result
in a useful ability to specialize. In addition, both Java and C# now provide
a language feature allowing default interface methods which provide for a simpler but no less
extensible base.</p>
<p>In other cases, specialization is used to provide quite deep hierarchies of
classes, for example Flow Element -&gt; Aspect Engine -&gt; Cloud Aspect Engine -&gt;
Device Detection Cloud Engine. This provides for numerous extensibility points
but means that for any resulting Engine, it can be quite difficult to find
out at what level of the inheritance hierarchy a desired inherited feature
is implemented.</p>
<h2 id="parameterized-types-and-crtp">Parameterized types and CRTP</h2>
<p>Generics are used throughout the reference implementations and serve, for
example, to bind functionality to data structures and metadata.
This pattern is used effectively
but the limited number of top level classes makes it harder to find what
data structure is being used at what level of the parameterized class.</p>
<h2 id="dependency-injection-and-inversion-of-control">Dependency injection and inversion of control</h2>
<p>Limited use is made of these techniques. Notably, the concept of shared services
does allow the injection of caches, data update and other services.</p>
<p>Greater use of dependency injection would allow the simplification of class
hierarchies. As well as simplifying test configuration and the like.</p>
<h2 id="builders">Builders</h2>
<p>Builders are an intrinsic part of the current reference architecture and,
like the classes they build, are extensively subclassed and parameterized. There
are builders for many significant components and for all Engines (and each of their
supertypes).</p>
<p>Considerable simplification would theoretically be possible between the builders and
their target classes in the area of Property getters and setters, as well as
the target class constructors, of which there are usually several.</p>
<p>It&rsquo;s not usually very easy to establish the default value of a configuration item that
can be set in a builder, since it can be set in the target class, a superclass
of that target class, the builder or a superclass of the builder.</p>
<p>This could be resolved by simplifying the constructors and defining a standard<br />
approach to default values.</p>
<p>A Pipeline is usually constructed using a fluent builder which accepts Flow Elements
being added to it in flow order. Those Flow Elements are usually created using
fluent builders of their own, which may in turn accept features, such as a cache,
constructed using a builder of its own.</p>
<p>A special builder is provided to simplify the creation of commonly used Pipelines
for on-premise or cloud Device Detection. This hides the complexity
of Pipeline creation by automatically inserting elements, and choosing
default values, but the price for that simplification is considerable. There is
more code to maintain, more creation scenarios, which require explanation in
documentation and examples. The special Pipeline builder is also difficult or
impossible to use with web integrations and cannot be used when building from a
configuration file. Finally, if the user is using this builder and decides they
need some capability that is beyond its scope, they have to migrate to the
&lsquo;standard&rsquo; Pipeline builder.</p>
<p>On the whole, we prefer solutions that will reduce complexity for users. However,
care should be taken to try to avoid the issues described above.</p>

<hr/>
<h1 id="usage-examples">Usage examples</h1>
<p>For the most part, the Pipeline specification is describing the pieces of an
empty data processing system. Many use-cases only make sense in the context
of some concrete usage of that system. As such, it may be helpful to look at
other use-case documents such as
<a href="../device-detection-specification/usage-examples.md">Device Detection</a></p>
<h2 id="creating-elements-and-pipelines">Creating elements and Pipelines</h2>
<p>Creating <strong>Flow Elements</strong> should always be done using a consistent mechanism.
In the case of C#, we use a separate builder class. For more details on this,
see the <a href="conceptual-overview.md#flow-element-builder">Flow Element builder</a>
section in the conceptual overview.</p>
<pre><code class="language-c#">var element = myElementBuilder
  .SetConfigurationFlag(true)
  .Build()
</code></pre>
<p>As with <strong>Flow Elements</strong>, C# also uses separate builder class when creating
<strong>Pipelines</strong>:</p>
<pre><code class="language-c#">var pipeline = pipelineBuilder
  .AddElement(element)
  .Build()
</code></pre>
<p>Note that many users will not create the elements and Pipeline in code
as shown above.
Instead, they will use a configuration file which is then used to
create the required element and Pipeline instances.</p>
<p>See <a href="features/pipeline-configuration.md">Pipeline configuration</a> for more
details.</p>
<h2 id="processing-data">Processing data</h2>
<p>Once the Pipeline has been created, processing a request can generally
be broken down into 4 steps:</p>
<ol>
<li>Create <strong>Flow Data</strong>:</li>
</ol>
<pre><code class="language-c#">var flowData = pipeline.createFlowData();
</code></pre>
<ol>
<li>Add <a href="features/evidence.md">Evidence</a>:</li>
</ol>
<pre><code class="language-c#">flowData.AddEvidence(&quot;query.evidence-key&quot;, &quot;evidence value&quot;);
</code></pre>
<ol>
<li>Request the <strong>Pipeline</strong> to process the data:</li>
</ol>
<pre><code class="language-c#">flowData.Process();
</code></pre>
<ol>
<li>Access the results:</li>
</ol>
<pre><code class="language-c#">var result = flowData.GetFromElement(element);
</code></pre>
<p>See <a href="features/access-to-results.md">access to results</a> for more detail on
the different ways to access results.</p>

<hr/>
<h1 id="packaging-and-structure">Packaging and structure</h1>
<p>Some general guidance as to how to structure an implementation based on
51Degrees experience.</p>
<h2 id="modularity">Modularity</h2>
<p>Using language-provided modularity features to provide separation
of concerns and to provide for applications being able selectively to
use features  without having to import unused features.</p>
<p>Excessive modularity, of course, makes the libraries hard to use.</p>
<p>Use of transitive dependencies can be very helpful and allow definition
of a single library aggregation. Most of the dependencies in Pipeline
are required for most use cases. However, if it is of concern that various
features are not included then facilities such as Maven&rsquo;s optional dependency can
be used.</p>
<h2 id="reference-modularity">Reference modularity</h2>
<p>51Degrees Pipeline reference implementations are developed in a single repository
allowing for a single build cycle. Specific features, such as Device Detection,
use separate repos.</p>
<p>Pipeline itself is modularized as follows:</p>
<ul>
<li><strong>Common</strong> base utilities potentially of wider application than Pipeline</li>
<li><strong>Core</strong> features essential to Pipeline, Flow Data, Flow Elements etc.</li>
<li><strong>Engines</strong> base classes providing features that are beyond what is provided in Flow Elements</li>
<li><strong>Web</strong> Adaptors and features to assist with use of Pipeline in a Web environment</li>
<li><strong>51Engines</strong> features specific to 51Degrees and 51Degrees Engines:</li>
<li><strong>ShareUsage</strong></li>
<li><strong>SetHeaders</strong></li>
<li><strong>Sequence</strong></li>
<li><strong>Engine Implementations</strong> Separate Modules for each of the following:</li>
<li><strong>JSON</strong></li>
<li><strong>JavaScript</strong></li>
<li><strong>CloudRequest</strong></li>
</ul>
<p>This diagram illustrates the structure of .NET NuGet packages:</p>
<p><img src="images/v4%20Packages.png" alt="Illustration of package structure" /></p>
<h2 id="cross-language-modularity">Cross-language modularity</h2>
<p>We use Git for our repository management and this allows us to share certain
items, such as test data, between languages using Git <a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules">submodules</a>.</p>
<h2 id="versioning">Versioning</h2>
<p>We distribute Pipeline with a single version number for all modules/artifacts.
In principle, using an aggregator module would allow both simple update
and multiple distinct module versions, but we have considered that there
are insufficient advantages to this approach.</p>
<h2 id="examples">Examples</h2>
<p>We do not distribute examples as compiled artifacts.</p>
<p>There would be advantages to distributing examples using a separate repository
to the code they exemplify in order to
ensure that distributed library artifacts are used. However, this would make
regression testing of the examples more complicated during the release cycle.</p>
<p>For more details, see <a href="required-examples.md">required examples</a>.</p>
<h2 id="tests">Tests</h2>
<p>Automated tests and expected to be present in the same repository as the
API code and will be run as part of CI/CD workflows.
For more details, see <a href="automated-testing.md">automated testing</a>.</p>
<h3 id="test-data">Test data</h3>
<p>We recommend that for convenience, test data of some kind is distributed with
library code and examples. We also recommend that alternative means of updating
test data are provided.</p>

<hr/>
<h1 id="required-examples">Required Examples</h1>
<h2 id="general">General</h2>
<p>It is recommended that the following features are demonstrated in examples:</p>
<ul>
<li>Pipeline build from options</li>
<li>Use of fluent builder</li>
<li>Creation of a Flow Element, and On-Premise and Cloud Engines</li>
<li>Determination of various metadata associated with a Flow Element, such as
Evidence accepted and Flow Data key</li>
</ul>
<p>See <a href="../../device-detection-specification/part3/required-examples.md">Device Detection required examples</a> for more detailed recommendations</p>
<h2 id="suggested-examples">Suggested Examples</h2>
<p>The examples in the reference implementations demonstrate determination of a
star sign from a birthdate, and do so in a number of different ways:</p>
<ul>
<li>
<p>Using client side Evidence, the example prompts the user for a date using a
JavaScript dialog box, in Java this is implemented using Spring MVC</p>
</li>
<li>
<p>Using a Cloud Request Engine - this needs a cloud endpoint which may be
built and run as a local server</p>
</li>
<li>
<p>Using a Flow Element that returns star sign given a date of birth as
Evidence.</p>
</li>
<li>
<p>Using an On-premise Engine that demonstrates getting a star sign from a date
similarly to the Flow Element but using a disk data source</p>
</li>
</ul>
<p>Reference implementations also contain the following examples:</p>
<ul>
<li>Create a Pipeline that shares usage with 51degrees configured from options file,
although this example is runnable you can&rsquo;t actually &ldquo;see&rdquo; that it is working.</li>
</ul>

<hr/>
<h1 id="automated-testing">Automated Testing</h1>
<h2 id="types-of-tests">Types of tests</h2>
<p>The reference implementations contain a considerable number of tests both
to support functional testing and regression testing.</p>
<p>The tests provided are almost all <a href="https://en.wikipedia.org/wiki/Unit_testing">unit tests</a>, though some unit tests
also serve as <a href="https://en.wikipedia.org/wiki/Integration_testing">integration tests</a> -
for example, requiring access to live cloud server instances to pass - however
they are not distinguished as such in continuous integration[^CI]. Note that
some tests are perhaps incorrectly named as integration tests.</p>
<p>[^CI]: For example, integration testing is often carried out on a push
to a particular branch of a repo, which provides access to test servers etc.
rather than being carried out locally on a developer&rsquo;s local machine.</p>
<h2 id="performance-tests">Performance Tests</h2>
<p>Some level of performance regression testing is carried out in certain areas.
This is, of necessity, a gross test, since unit tests are carried out in a
wide range of environments during CI and automated build and distribution.</p>
<p>Performance benchmarking is not carried out as part of automated testing. Hence,
external test tools, such as JMeter, are not used as part of automated testing.</p>
<h2 id="test-frameworks">Test Frameworks</h2>
<p>The reference implementations make use of standard test frameworks. Java uses
JUnit4 and JUnit5 and C# uses Visual Studio Test Tools.</p>
<h2 id="test-tools">Test Tools</h2>
<p>Mocking frameworks, in particular Mockito, are used quite extensively. It is
a matter of debate as to what extent is appropriate for such tools. On the
one hand they make creating stub implementations approachable, especially where
injection of test dependencies is not possible. On the other hand, it would
often be better to consider the need for injection of test dependencies in the
design of the classes under test.</p>
<p>It is somewhat inconsistent to provide interfaces and default
implementations of those interfaces without considering test implementations
of those interfaces, and use of those test implementations, rather than
using a mocking tool on the default implementation.</p>
<p>Note in particular that mocking a logger can&rsquo;t be considered
good practice since the logging frameworks concerned provide no-op loggers
for such purposes.</p>
<p>Use of mocking tools can have unwanted side effects in terms of performance
and in terms of making it quite difficult to determine causes of test failures
when they result from incorrect specification of the mocked object. Debugging
mocks can be a lot harder than debugging test implementations.</p>
<h2 id="test-cases">Test Cases</h2>
<p>This section itemises key required tests, by module of the reference
implementation they are found in.</p>
<p>In all cases all methods of all classes must be tested for correct operation
when valid data is supplied, and correct exceptional operation is taken for
incorrect data. The cases listed here are mostly concerned with testing that
underlying functionality is correctly implemented where internal state of
the object can vary. For example a Flow Data can only be processed once, so
there must be a test to check that an attempt to process it twice, fails.</p>
<p>Numerous additional tests exist (to a total of around 500, running to 100s of
thousands of lines of code) in the reference implementations and the code of
those implementations should be consulted.</p>
<h3 id="core">Core</h3>
<p>TypedKeyMap :
- (ThreadSafe and non-ThreadSafe) test each of the methods.</p>
<p>Pipeline:</p>
<ul>
<li>test for correct processing of Flow Data with one, two and three Flow Elements.</li>
<li>test of correct operation of parallel flow.</li>
<li>test that <code>FlowData.stop()</code> works correctly.</li>
<li>test that throwing exceptions while processing terminates processing, or doesn&rsquo;t
depending on configuration.</li>
<li>test that Flow Data contains correct errors at end.</li>
</ul>
<p>PipelineBuilder and PipelineOptions:
- check exceptional operation such as adding a closed Flow Element
- check build from options
- check Build from serialized options with abbreviated names
- check for serialized options containing wrong option and values
- check for constructor values
- check build from fluent builder</p>
<p>Flow Data:</p>
<ul>
<li>check that Flow Data is processed exactly once on call of process</li>
<li>check that attempt to process twice fails</li>
<li>check that access to Flow Data when Pipeline closed fails</li>
<li>check that access to Flow Data results before processing fails</li>
</ul>
<p>Flow Element:</p>
<p>Create a Test Element and associated data
- check correct process() logic
- check for correct creation of associated data type
- check for correct access following processing</p>
<p>Java Only:</p>
<p>Lookup: The Java reference implementation allows interpolation of values
(environment variables etc.) in Pipeline options files. Test for correct
operation of the various items that can be interpolated.</p>
<h3 id="engines">Engines</h3>
<p>Pipeline Overhead:</p>
<p>Create a test Pipeline and check that the processing costs is within
reasonable bound for the cases:
- repeated execution of Pipeline
- repeated execution of Pipeline with caching enabled on Engine
- repeated execution of Pipeline with parallel Flow Data</p>
<p>AspectEngine:
- check Aspect Engine uses cache correctly
- if lazy loading is implemented, check that it fires only at the right
time and only once</p>
<p>DataUpdateService:</p>
<p>DataUpdate is a complex process with many options.
- check that the options cannot be set inconsistently
- check that the callbacks are fired on update completion successfully
- check that Engine refresh is triggered on file update if configured
- check that programmatic update works correctly and resets remote update properly
- check that remote update triggers correctly and resets correctly in the event
of both successful and unsuccessful download, with various failure scenarios
such as HTTP timeout, HTTP 429, 400, MD5 check failure etc.
- check that Engine refreshes with correct data and that any data associated
with earlier copy is freed correctly
- carry out a repeated refresh test to look for memory leaks</p>
<p>MissingPropertyService:</p>
<ul>
<li>check that &ldquo;upgrade required&rdquo; is returned for a Property that is available in a different tier</li>
<li>check that &ldquo;unknown&rdquo; is return for a Property that is not known</li>
<li>check that &ldquo;not in resource&rdquo; is returned for Cloud Engine</li>
<li>check unknown returned otherwise</li>
</ul>
<h3 id="enginesfiftyone">Engines.Fiftyone</h3>
<p>ShareUsage:</p>
<ul>
<li>
<p>check that ShareUsage substitutes illegal XML characters correctly and truncates values</p>
</li>
<li>
<p>check that ShareUsage operates correctly, retrying failed data etc.</p>
</li>
<li>
<p>check that sending stops when queue is full and resumes when it is no longer so</p>
</li>
<li>
<p>check that all data in the queue are sent</p>
</li>
<li>
<p>check minimum batch size and maximum batch size</p>
</li>
<li>
<p>check operation of tracker</p>
</li>
<li>
<p>check operation of filtering of headers</p>
</li>
<li>
<p>check operation of SessionID</p>
</li>
<li>
<p>check operation on shut down</p>
</li>
<li>
<p>check that ShareUsage does not impose an undue burden on performance</p>
</li>
</ul>
<p>SetHeaders</p>
<ul>
<li>check that headers are set correctly, where multiple attempts to set same header, for example</li>
</ul>
<h3 id="jsonbuilder">JSONBuilder</h3>
<ul>
<li>check that the output is valid</li>
<li>check that the maximum iterations is observed</li>
<li>check that disallowed elements are not put in the output</li>
<li>check that the serialization is correct</li>
<li></li>
</ul>
<h3 id="javascriptbuilder">JavaScriptBuilder</h3>
<ul>
<li>check for normal, empty, invalid and delayed execution Properties</li>
</ul>
<h3 id="web">Web</h3>
<p>Tests in this area will vary by the Web support features of the language and platform.</p>
<p>Some Aspects of these tests look rather like integration tests and ideally will
require a <a href="https://en.wikipedia.org/wiki/Headless_browser">headless browser</a> for execution.</p>
<p>Things to check:
- operation of the SetHeaders Engine
- operation of the JSON and Javascript Engines
- operation of the Sequence Element</p>
<p><span style="color:yellow">hard to know what else to say?</span></p>

<hr/>
<h1 id="pipeline-configuration">Pipeline configuration</h1>
<h2 id="summary">Summary</h2>
<p>Many Flow Elements have numerous configuration options, it is also possible
to configure Pipelines in many ways.</p>
<p>In order to make configuration as simple as possible for users, it is required
that elements and Pipelines can be configured and created using either a pure
code approach, or a configuration file.</p>
<p>For consistency, configuration files should be as similar as possible between
languages.</p>
<h2 id="pipelines">Pipelines</h2>
<ul>
<li>During construction, Pipelines must have the ability to add elements/Engines.
These will run in sequence in the order they are added.</li>
<li>During construction, Pipelines may have the ability to add multiple
elements/Engines that will run in parallel (where the language supports this -
See <a href="../advanced-features/parallel-processing.md">parallel processing</a> for a
discussion of the complexities this adds).</li>
</ul>
<p>For example:</p>
<pre><code class="language-c#">var pipeline = pipelineBuilder.Add(s1).AddParallel([p1,p2]).Add(s2).Build()
</code></pre>
<p>This would create a Pipeline that performs the following processing:
- Execute s1.
- When s1 is finished, p1 and p2 are started in parallel.
- When both p1 and p2 are complete, s2 is started.</p>
<h2 id="flow-elements">Flow Elements</h2>
<ul>
<li>Elements/Engines may or may not have configuration options to customize the
processing that they perform.</li>
<li>The configuration file definition must be as similar as possible to configuration
files for other languages.</li>
<li>All configuration options should use the same names in the configuration file
as would be used when configuring in code.</li>
<li>Where feasible, all configuration options available in code should be configurable
via a file. The exceptions are usually options that take complex objects, which
cannot easily be defined in a text-based file.</li>
</ul>
<h2 id="deserialization">Deserialization</h2>
<p>Configuration files must be human-readable and consistent between languages.
Consequently, we don&rsquo;t want any type information or metadata appearing in
these files. This implies some limitations on the types that can be deserialized
from values in the files, as additional logic may need to be added for each type.</p>
<p>To date, the following types are supported in configuration files for all languages:</p>
<ul>
<li>string</li>
<li>boolean</li>
<li>numeric (integer or floating point)</li>
<li>list of strings (represented as a comma-separated string)</li>
<li>enumeration value (represented as the string name of the value)</li>
</ul>
<h2 id="sample-configuration-files">Sample configuration files</h2>
<p>TODO - these sample files are not yet publicly available, they are in
internal <code>develop</code> branches.</p>
<p><a href="https://github.com/51Degrees/device-detection-dotnet/blob/master/Examples/sample-configuration.json">.NET</a>
<a href="https://github.com/51Degrees/device-detection-java/blob/master/device-detection.examples/console/src/main/resources/gettingStartedOnPrem.xml">Java</a></p>

<hr/>
<h1 id="web-integration">Web integration</h1>
<h2 id="overview">Overview</h2>
<p>The web integration feature is intended to simplify usage of the Pipeline API
in websites/applications that are built using a particular web framework.</p>
<p>The exact details may vary significantly based on the web framework that
is being used. The capabilities and common usage of the target web framework
should be fully understood so that the integration is in keeping with that
ecosystem, rather than simply repeating what worked for some other
language/framework.</p>
<p>Some common tasks that the web integration may perform are:</p>
<ul>
<li>Creation of <strong>Pipeline</strong> on start-up.</li>
<li>Manage <strong>Flow Data</strong> lifecycle</li>
<li>Create <strong>Flow Data</strong> when request comes in</li>
<li>Populate Evidence values and call &lsquo;Process&rsquo;</li>
<li>Make the processed <strong>Flow Data</strong> easily accessible to other parts of the
application so the results can be used.</li>
<li>Handle <a href="resource-cleanup.md">resource cleanup</a> once request handling is
completed.</li>
<li>Handling requests for <a href="#client-side-features">client-side</a> functionality.</li>
<li>Set HTTP response headers to request additional information.</li>
</ul>
<h2 id="pipeline-configuration">Pipeline configuration</h2>
<p>The web integration makes use of several <strong>Flow Elements</strong> in order to support
<a href="#javascript-properties">client-side</a> functionality.</p>
<p>Where the web integration is responsible for creation of the <strong>Pipeline</strong>, it
must also ensure that these additional <strong>Flow Elements</strong> will be present.</p>
<ul>
<li>The <a href="../pipeline-elements/sequence-element.md">Sequence Element</a> must be
present. If not, it should be added as the first element in the Pipeline.</li>
<li>The <a href="../pipeline-elements/json-builder.md">JSON Builder Element</a> must be
present. If not, it should be added as the penultimate element.
(Immediately before the JavaScript Builder Element).</li>
<li>The <a href="../pipeline-elements/javascript-builder.md">JavaScript Builder Element</a>
must be present. If not, it should be added after all other elements.</li>
</ul>
<p>Another <strong>Flow Element</strong> is needed to allow the web integration to automatically
set HTTP response headers.</p>
<ul>
<li>The <a href="../pipeline-elements/set-headers-element.md">Set Headers Element</a> must
be present. If not, it should be added after all other elements.</li>
</ul>
<p>For all of these elements, there must be configuration options to allow
users to prevent them being added if they wish to do so.</p>
<h2 id="populating-evidence">Populating Evidence</h2>
<p>The web integration should automatically populate <a href="evidence.md">Evidence</a> from
the web request.</p>
<p>It may use the Pipeline&rsquo;s <a href="advertise-accepted-evidence.md">accepted Evidence</a>
feature to determine if individual values should be added to Evidence or not.</p>
<p>An alternative approach would be to wrap the web request structure itself as
Evidence, and hence defer processing until the Evidence is actually used.</p>
<p>In any case, the list below illustrates the type of data that should be used
and the Evidence names they would be associated with.</p>
<ul>
<li>All HTTP headers. (Except cookies header) Key must be <code>header.[header name]</code></li>
<li>All cookies. Key must be <code>cookie.[cookie name]</code></li>
<li>All query string parameters. Key must be <code>query.[parameter name]</code></li>
<li>All form parameters from POST requests. Key must be <code>query.[parameter name]</code></li>
<li>Where there is an HTTP session object, data stored in the session. Key must
be <code>session.[value name]</code></li>
<li>Public client IP. Key must be <code>server.client-ip</code></li>
<li>Request protocol. Can come from the request itself or headers such as
<code>X-Origin-Proto</code> or <code>X-Forwarded-Proto</code>. Key must be <code>header.protocol</code></li>
</ul>
<h2 id="setting-response-headers">Setting response headers</h2>
<p>The <a href="../pipeline-elements/set-headers-element.md">Set Headers Element</a> will
produce an output that describes which response headers should be set to which
values.</p>
<p>However, it has no access to the web request itself. Consequently, the web
integration logic must take this output and actually set the required response
headers.</p>
<p>Where the required headers are already set to some value, the new value must
be appended, rather than replacing the existing value.</p>
<h2 id="client-side-features">Client-side features</h2>
<p>There are two major client-side features that the web integration must provide:
1. Enable the execution of JavaScript snippets which can be used to gather
additional Evidence. Handle passing this data back to the <strong>Pipeline</strong> for
processing.
2. Allow the user to access results on <strong>Pipeline</strong> processing in client side
code.</p>
<h3 id="access-to-results">Access to results</h3>
<p>Generally, this is achieved by adding a specific JavaScript include to the HTML
page. The web integration intercepts the request to this URL and serves a
JavaScript object that can be used to access the results from processing.</p>
<h3 id="javascript-snippets">JavaScript snippets</h3>
<p>Aspect Engines can return Properties with a type of
<a href="properties.md#the-javascript-type">Javascript</a>. For these Properties,
the Property value contains JavaScript code that is intended to be
executed on the client device.</p>
<p>As these JavaScript Property values are part of the result set, they will
already be accessible in client-side code through the JavaScript include that
is discussed in the section above.</p>
<p>Therefore, in order to meet this requirement, the JavaScript include must
be enhanced to perform the following steps:
1. Identify these JavaScript Property values
2. Execute the snippets
3. Call back to the server, including the results from the execution of the
snippets
4. Use the result from the callback to update the result data set
5. Repeat if there are any JavaScript Property values in the new result set.
(only repeat up to a configurable limit in order to avoid infinite loops)</p>
<h3 id="flow-elements">Flow Elements</h3>
<p>These features are implemented using the web integration logic itself, along
with several <strong>Flow Elements</strong>:</p>
<ul>
<li><a href="../pipeline-elements/sequence-element.md">Sequence Element</a> - Used to
prevent the infinite loops described in the section above.</li>
<li><a href="../pipeline-elements/json-builder.md">JSON Builder Element</a> - Converts the
Property values in the current <strong>Flow Data</strong> into a JSON data object.</li>
<li><a href="../pipeline-elements/javascript-builder.md">JavaScript Builder Element</a> -
Takes the output from JSON Builder Element and packages it within a JavaScript
template.</li>
</ul>
<h3 id="intercepted-urls">Intercepted Urls</h3>
<p>In order for this to work, the web integration needs to intercept requests
to two urls. These should be configurable, but the default values are:</p>
<ul>
<li><code>/51Degrees.core.js</code> - Serves the JavaScript produced by JavaScript Builder Element.</li>
<li><code>/51dpipeline/json</code> - Serves the JSON produced by JSON Builder Element.</li>
</ul>
<h4 id="client-side-caching">Client-side caching</h4>
<p>Where possible, we want to prevent the client from evaluating JavaScript or
making requests unnecessarily. To achieve this, the web integration will
need to include logic to set HTTP cache control headers when responding to
requests to these intercepted endpoints.</p>
<h5 id="storing-results-of-post-requests">Storing results of POST requests</h5>
<p>Requests to the JSON endpoint will be POST requests, as opposed to the GET
requests made to the JavaScript endpoint.</p>
<p>This is a problem because most browsers do not consider POST requests to be
cache-able and will not respect cache headers.</p>
<p>The reference implementations work around this by using the session storage
API. See the
<a href="../pipeline-elements/javascript-builder.md">JavaScript Builder Element</a>
for more details.</p>
<h5 id="caching-example">Caching example</h5>
<p>Below is a request/response diagram showing what we want to happen when an
initial request is made (in red) and the user then moves to another page on
the same site (in blue).
See the descriptions below for a detailed walkthrough of what is happening
on each line.</p>
<p><img src="../images/JavascriptProperties-RequestResponse.png" alt="JavaScript Properties Request Response" /></p>
<h6 id="line-1-first-request-to-javascript-endpoint">Line 1: first request to JavaScript endpoint:</h6>
<p>A client connecting to a web server that uses a Pipeline API with web
integration will typically be directed to download a script such as
51Degrees.core.js. The local cache will not have this as it is the first
request. Proxy and server caches must never cache this resource, so will also be
cache misses. The web integration code will intercept the request on the server
and serve the JavaScript that is produced by the JavaScript Builder Element in the
Pipeline.</p>
<p>The JavaScript in the response will then run on the client. If any JavaScript
Properties are present, they will be executed. Any new pieces of Evidence
produced because of processing these JavaScript Properties will be added to the
parameters list. A request will then be sent to the callback URL.</p>
<h6 id="line-2-first-request-to-json-endpoint">Line 2: first request to JSON endpoint:</h6>
<p>As this is the first request, there is nothing in the session storage.
Proxy and server caches must never cache this resource. On the server, the
request to the JSON endpoint will again be intercepted and handled. This time,
by responding with the output from the JSON Builder Element.</p>
<p>The JavaScript code running on the client will update its JSON data with the one
from the response. In addition, the payload will be stored in session storage
using the Session ID as the key, the JavaScript Properties that ran will be
flagged in session storage also and the sequence number sent in the callback
request body will be incremented.</p>
<p>If the JSON payload still contains JavaScript Properties, the process repeats.</p>
<h6 id="line-3-second-request-to-json-endpoint-different-parameters-to-1st-request">Line 3: second request to JSON endpoint (different parameters to 1st request)</h6>
<p>This time, the sequence number in the request body will be 2 and new Evidence
will have been provided. The session storage will be invalid as the parameters have
changed. The request to the callback URL is made with the new Evidence and any
existing Evidence to get an updated JSON payload. The JavaScript will again
update its internal JSON data with the one from the response and store it in
session storage along with all the JavaScript Properties that have been run.</p>
<h6 id="line-4-skipping-second-request-to-javascript-endpoint">Line 4: skipping second request to JavaScript endpoint</h6>
<p>We now assume that the user moves to another page on the same website. This page
also includes the directive to download 51Degrees.core.js. This time, the local
cache can serve the same JavaScript response that it used previously.</p>
<h6 id="line-5-6-skipping-third-and-fourth-requests-to-json-endpoint">Line 5 + 6: skipping third and fourth requests to JSON endpoint</h6>
<p>The script will be the original version that was obtained from the JavaScript
endpoint previously. As such, it will go through the same process of checking
session storage for existing results and executing JavaScript Properties.</p>
<p>First, the session storage is checked to see if the JavaScript Properties to be
run have been run already. If this is the case then the session storage is
checked to see if it contains a JSON payload using the cached Session ID as the
key. If the payload is found, then this is loaded into the JavaScripts internal
JSON data and no requests to the callback URL need to be made.</p>
<p>This will then repeat as before for any JavaScript Properties in the new payload.</p>
<h5 id="cache-header-detail">Cache header detail</h5>
<p>The HTTP response headers that must be set for the JSON and JavaScript endpoints
are:</p>
<table>
<thead>
<tr><th> <strong>Header</strong>      </th><th> <strong>Values</strong>                                                                          </th><th> <strong>Purpose</strong>                                                                                      </th></tr>
</thead>
<tbody>
<tr><td> Cache-Control   </td><td> max-age=1800 private                                                                </td><td> Cache item lifetime is 30 minutes. Only local client caches should cache this content.           </td></tr>
<tr><td> Vary            </td><td> all headers in Pipeline Evidence key filter (e.g. User-Agent)                       </td><td> Let the cache know that if one of these headers changes, the cached content must be re-fetched.  </td></tr>
<tr><td> ETag            </td><td> Calculated hash of ALL the Evidence values in Evidence filter key for this Pipeline </td><td> Assists caches in re-validating expired content                                                  </td></tr>
<tr><td> Content-Type    </td><td> application/x-javascript or application/JSON                                        </td><td> Indicate the type of content being returned                                                      </td></tr>
<tr><td> Content-Length  </td><td> Content length in bytes                                                             </td><td> Indicate the expected length of the content                                                      </td></tr>
</tbody>
</table>
<p>In order to validate the ETag, the JSON and JavaScript endpoints must check for
an &lsquo;If-None-Match&rsquo; header in the request. This will be sent when a cached items
lifetime has expired and the cache needs to check if what it holds is still
valid.</p>
<p>If the value in the &lsquo;If-None-Match&rsquo; header matches the calculated ETag value for
the current request, then the content in the cache is still valid and the
endpoint can just return a 304 status code. (Not modified)</p>
<p>Note on correctness  This process could lead to responses that are not strictly
correct if the JavaScript snippet is getting data values that might change over time.
For example, if we&rsquo;re using JavaScript to get location and the user has moved then
session storage will still contain the previous location lookup response.
In practice this seems unlikely to cause any real issues, as long as the cache
max-age is not too long. Max-age should be configurable to allow this to be addressed
if it is found to be an issue for a particular client.</p>

<hr/>
<h1 id="caching">Caching</h1>
<h2 id="overview">Overview</h2>
<p><strong>Aspect Engines</strong> may support the addition of a cache.
This is intended to improve performance when the Engine receives a process
request containing Evidence values that are sufficiently similar to a previous request.</p>
<p>As with any caching strategy, the implications for memory use and
performance should be investigated by profiling in the target environment.
Although we must certainly ensure that the caching implementation is doing its
job effectively, such concerns are primarily the responsibility of the end
user of the Pipeline API.</p>
<p>In practice, we have found that the primary use-case for caching is the
<a href="../pipeline-elements/cloud-request-engine.md">Cloud Request Engine</a>.
This works well when cloud requests are being made for one product.
(For example, Device Detection.) However, it becomes significantly less
effective when the cloud request is being made for multiple products.
At present, there are no plans to address this.</p>
<h2 id="process-flow">Process flow</h2>
<p>With a cache added, the logical execution of the process function within
the Engine will be something like this:</p>
<pre><code>var result = null
var cacheKey = null

if(cache is enabled)
  cacheKey = createKey(getRelevantEvidence(flowData))
  result = cache.Get(cacheKey)
endif

if(result == null)
  result = doNormalProcessing()

  if(cache is enabled)
    cache.Add(cacheKey, result)
  endif
endif

flowData.Add(engineDataKey, result);
</code></pre>
<p>Warning - don&rsquo;t take the pseudo code above as a template. Real production code
is likely to vary significantly from this in order to account for concurrency
concerns, error handling, other features, etc.</p>
<h2 id="generation-of-keys">Generation of keys</h2>
<p>All <strong>Flow Elements</strong> must <a href="advertize-accepted-evidence.md">advertise</a> the
Evidence keys that they make use of.
You will need to use this to build a list of the relevant Evidence keys
and values that are present in the <strong>Flow Data</strong>.</p>
<p>Other considerations when creating keys:
- Evidence values must always be added in the same Evidence key order.
For example, <code>query.user-agent</code> first, then <code>header.user-agent</code>, etc</p>
<ul>
<li>Comparison of Evidence keys must be case-insensitive. For example,
the following keys are considered the same:</li>
</ul>
<pre><code>&quot;query.user-agent&quot; = &quot;abc&quot;
</code></pre>
<pre><code>&quot;query.User-Agent&quot; = &quot;abc&quot;
</code></pre>
<ul>
<li>Comparison of Evidence values must be case-sensitive.</li>
</ul>
<h2 id="cache-implementation">Cache implementation</h2>
<p>The system should allow any cache conforming to a simple interface to be
used.
However, the default implementation should be a sharded LRU cache.
This will ensure that memory use is always well-defined and that the cache
can cope with concurrent requests reasonably well.</p>
<p>The cache must be configurable:</p>
<table>
<thead>
<tr><th> Configuration option </th><th> Default             </th><th> Description                                                           </th></tr>
</thead>
<tbody>
<tr><td> Size                 </td><td> 1000                </td><td> Number of items stored in the cache before it starts evicting things. </td></tr>
<tr><td> Concurrency          </td><td> Number of CPU cores </td><td> Number of shards in the cache.                                        </td></tr>
</tbody>
</table>
<p><a href="https://medium.com/@yewang2018/lru-cache-design-8257850a69fe">This article</a>
describes the internals of such a cache. You can also review the
<a href="https://github.com/51Degrees/pipeline-java/blob/master/pipeline.caching/src/main/java/fiftyone/caching/LruCacheBase.java">Java</a>
and <a href="https://github.com/51Degrees/caching-dotnet/blob/master/FiftyOne.Caching/LruCacheBase.cs">.NET</a>
reference implementations.</p>
<h2 id="data-lifetime-and-concurrency-issues">Data lifetime and concurrency issues</h2>
<p>The cache stores the instance of <strong>Aspect Data</strong> that was generated based
on the Evidence values in the key.</p>
<p>Where <a href="resource-cleanup.md">resource cleanup</a> is required, the lifetime
of such data objects is tied to the <strong>Flow Data</strong> that is generated for
that request.</p>
<p>However, cached instances can persist long after the original <strong>Flow Data</strong>
that resulted in their creation is gone.</p>
<p>Consequently, if the <strong>Element Data</strong> produced by an <strong>Engine</strong> requires
cleanup, then that Engine must not allow a cache to be added.</p>
<p>In addition, this functionality can result in a scenario where the
instance is accessed by multiple threads simultaneously.
If access to the <strong>Element Data</strong> cannot be guaranteed to be thread-safe,
then the Engine must not allow a cache to be added.</p>
<p>Design note - There are various routes we could potentially take to allow
caches to still work in the scenarios described above. (Creating a duplicate
of the instance, reference counting to ensure cleanup happens, etc.)
51Degrees has decided not to pursue these at present, so the current
implementations simply do not support adding a cache in these cases.</p>

<hr/>
<h1 id="thread-safety">Thread safety</h1>
<h2 id="flow-elements">Flow Elements</h2>
<p>The Pipeline API is designed to be used in highly concurrent environments
such as high traffic web servers.</p>
<p>Consequently, <strong>Pipeline</strong> and <strong>Flow Element</strong> implementations must be
capable of handling multiple concurrent requests to the <code>Process</code> function.</p>
<h2 id="flow-data">Flow Data</h2>
<p>In general user-facing data structures linked to <strong>Flow Data</strong> do not need to be
thread-safe as the most common use-case is that they will be accessed and
updated only on the current thread.
This ensures users get the best performance by default.</p>
<p>Where the <strong>Pipeline</strong> contains elements running in parallel, <strong>Element Data</strong> instances
will be added to the <strong>Flow Data</strong> in parallel. However, it is a useful optimization
to allow <strong>Flow Data</strong> to be non-thread safe in contexts where no parallel execution
is required.</p>
<p><strong>Flow Data</strong> instances are created by the Pipeline instance on which they
will be processed. The Pipeline can determine whether any Flow Elements are
to be processed in parallel and thus can determine whether to create thread-safe
Flow Data or not.</p>
<h3 id="evidence">Evidence</h3>
<p>Evidence collection stored within <strong>Flow Data</strong> needs to be thread safe for
concurrent read access and immutable once created.</p>
<h2 id="element-data">Element Data</h2>
<p>In general, <strong>Element Data</strong> instances do not need to be thread safe, as they
should only be accessed and updated from a single thread.</p>
<p>While it is certainly possible for a user to Engineer a scenario where an
instance is accessed from multiple threads. We do not consider it worthwhile
to cater for this scenario given the decreased performance and increased
complexity that it would require.</p>
<h2 id="aspect-data">Aspect data</h2>
<p>In contrast to Element Data, Aspect Data instances must be thread-safe as the
same instance may be used for multiple different calls to <code>Process</code> when
the <a href="caching.md">caching</a> feature is enabled.
If this is not possible for some reason then the Engine must not allow a cache
to be added.</p>

<hr/>
<h1 id="exception-handling">Exception handling</h1>
<h2 id="overview">Overview</h2>
<p>Exceptions and errors may occur at many places within the Pipeline
API. It is vital that these are presented and handled consistently.</p>
<p>In general, we aim to follow these principles:</p>
<ol>
<li>Exceptions and errors should be highly visible (e.g. display error message
and stop the process) by default in order to highlight issues during
development.</li>
<li>It must be possible for the user to configure the system to prioritize
remaining operational over making failures visible. Many users will
prefer this for production.</li>
</ol>
<p>In all cases, we must use standard language features where available to
let IDEs and users know what exceptions/errors a particular function can
throw.</p>
<h2 id="process-function">Process function</h2>
<p>One of the key points that failures can occur is in the &lsquo;Process&rsquo; function.
There may be any combination of <strong>Flow Elements</strong>, including custom
third-party ones in the <strong>Pipeline</strong>.</p>
<p>Consequently, exceptions and errors must be caught at the <strong>Pipeline</strong>
level.
By default, these errors should be added to the <strong>Flow Data</strong> errors
collection. Once all <strong>Flow Elements</strong> have completed processing, throw an
exception/error with all the stored errors included as sub-errors.</p>
<p>There must be an option to modify this behavior to just add these errors
to the errors collection and <a href="logging.md">log</a> them (I.e. don&rsquo;t throw an
exception/error at the end of processing). This option should be available
when the <a href="../conceptual-overview.md#pipeline-builder">Pipeline is created</a>
and be called <code>SuppressProcessExceptions</code> or similar.</p>
<h3 id="flow-elements">Flow Elements</h3>
<p><strong>Flow Elements</strong> should throw exceptions/errors freely, unless it makes
sense for an element to handle a specific error internally.
In general, it is the responsibility of the <strong>Pipeline</strong> to handle these for
the user as described above.</p>
<h2 id="flow-data-and-derived-accessors">Flow Data and derived accessors</h2>
<p>Apart from the &lsquo;Process&rsquo; function, almost all user interaction is handled
through <strong>Flow Data</strong>.
The general guidance is that these functions and accessors should only
throw errors/exceptions if the failure is likely due to something that
the API user has done wrong.</p>
<p>For example, passing a null parameter when a value is required or
attempting to access result data before &lsquo;Process&rsquo; has been called.</p>
<p>These are both things that the user should correct by making changes to
their code.</p>
<h2 id="web-integration">Web integration</h2>
<p>The <a href="web-integration.md">web integration</a> feature will be hooking into
the web request handling logic of the target language/framework. As such,
it will be executing code outside easily handled areas.</p>
<p>We must ensure that exceptions/errors that happen in these areas are
handled correctly in order to avoid the API taking down the customer&rsquo;s
production website.</p>
<h2 id="data-updates">Data updates</h2>
<p>The <a href="data-updates.md">data update</a> process runs on a background thread.
Consequently, it is outside any other error handling mechanisms and
must handle all its errors internally.</p>
<p>When errors do occur, they must be <a href="logging.md">logged</a> and must not
cause the process to crash.</p>
<h2 id="custom-exceptionserrors">Custom exceptions/errors</h2>
<p>There are several types of error that can be thrown by the Pipeline API.
The precise naming will be language-dependant, but in C#, these are:</p>
<h3 id="property-missing-exception">Property Missing Exception</h3>
<p>A Property missing exception is thrown if an attempt is made to access a
Property that does not exist in the <strong>Flow Data</strong>.</p>
<p>See <a href="properties.md#missing-properties">missing Properties</a> for more details.</p>
<h3 id="pipeline-configuration-exception">Pipeline Configuration Exception</h3>
<p>Can be thrown by any Pipeline, Element or Pipeline/Element builder. This
exception is used to indicate that something in the provided configuration is
preventing the creation or execution of the Pipeline.</p>
<h3 id="cloud-request-exception">Cloud Request Exception</h3>
<p>Can be thrown by the <a href="../pipeline-elements/cloud-request-engine.md">CloudRequestEngine</a>
following requests to a cloud service. Must be populated with details
relevant to the failure (For example, when a 429 error occurs, the
exception must include the value of the &lsquo;Retry-After&rsquo; header so that
the user can act on it)</p>

<hr/>
<h1 id="evidence">Evidence</h1>
<h2 id="overview">Overview</h2>
<p>Evidence is the name for the input values added to a <strong>Flow Data</strong> instance.</p>
<p>It is stored as key-value pairs and is used by <strong>Flow Elements</strong> within the
<strong>Pipeline</strong> and is immutable once created.
Keys should be case-insensitive and will usually be split into &lt;prefix&gt;.&lt;field&gt;.</p>
<p>Currently, defined examples of keys are:</p>
<ul>
<li><code>header.user-agent</code></li>
<li><code>header.[header-name]</code></li>
<li><code>cookie.[cookie-name]</code>*</li>
<li><code>server.client-ip</code></li>
<li><code>server.host-ip</code></li>
</ul>
<p>Any new Evidence should be defined in a similar manner.</p>
<p>* Note that the &lsquo;cookie&rsquo; prefix is a bit of a special case as cookies are supplied
to the web server using an HTTP header. Generally, 51Degrees Engines will not make
use of <code>header.cookie</code>. Cookie values must be under <code>cookie.</code> keys in order to be
used.</p>
<p>The prefix indicates where the value has come from. Currently, defined prefixes are:</p>
<ul>
<li><code>query</code>  Used for Evidence specifically set by the application, or values supplied
in a query string or the body of a post request. The suffix is the parameter name.</li>
<li><code>header</code>  Evidence came from an HTTP header. The suffix is the header name.</li>
<li><code>cookie</code>  Evidence came from a cookie. The suffix is the cookie name.</li>
<li><code>server</code>  Evidence came from a server that received a request but did not fit into
any other category. For example, the IP address of the server.</li>
<li><code>fiftyone</code>  used internally by 51Degrees.</li>
<li><code>location</code>  Used in some cases to supply geolocation information.</li>
</ul>
<p>The prefixes above are in order from highest to lowest precedence. I.e. if the same
Evidence value is available with two different prefixes (For example,
<code>header.user-agent</code> and <code>query.user-agent</code>), then the entry whose prefix is earlier
in the list above should be used.</p>
<p>If any other prefixes are present then their order of precedence is alphabetical.
This rule just ensures that any conflicts are resolved deterministically.
For example the <a href="../pipeline-elements/cloud-request-engine.md#processing">Cloud Request Engine</a></p>
<h2 id="adding-evidence-values">Adding Evidence values</h2>
<p>Evidence is immutable. However, it may be desireable for some <strong>Flow Elements</strong>
to add new values to Evidence for later elements to use.</p>
<p>In order to allow for this scenario, we suggest creating a helper function
that will pull a value from an existing <strong>Element Data</strong> if available, or
fallback to pulling it from Evidence if needed.</p>
<p>For example, if Device Detection Engine requests <code>query.sec-ch-ua-platform</code>
from this function, it would return a Property value from any <strong>Element Data</strong>
with that Property name.
It there were no such Property, if would return the value from Evidence entry
that matched that name.
If multiple <strong>Element Data</strong> instances include Properties with this name,
an exception/error should be thrown.</p>
<p>This function may be defined on <strong>Flow Data</strong> itself, as a separate helper, or
both. That is an implementation detail that may depend on the language and
design patterns being used.</p>

<hr/>
<h1 id="resource-cleanup">Resource cleanup</h1>
<h2 id="summary">Summary</h2>
<p>There must be some mechanism to clean up system resources
associated with various instances:</p>
<table>
<thead>
<tr><th> Type         </th><th> Description                                                                                                                             </th></tr>
</thead>
<tbody>
<tr><td> Element Data </td><td> If the instance contains any native (C/C++) resources, it must clean them up when triggered.                                            </td></tr>
<tr><td> Flow Data    </td><td> Trigger clean up of contained Element Data instances.                                                                                   </td></tr>
<tr><td> Flow Element </td><td> Clean up large in-memory data items, file handles, etc.                                                                                 </td></tr>
<tr><td> Pipeline     </td><td> Trigger clean up of Flow Elements that it contains. This behavior is configurable to accommodate sharing of elements between Pipelines. </td></tr>
</tbody>
</table>
<p>Note: In most scenarios the user application is responsible for creating Flow Data from the Pipeline and for its later disposal.
However, see <a href="web-integration.md">web integration</a> for further notes
on where this is not the case.</p>
<h2 id="detail">Detail</h2>
<h3 id="pipeline">Pipeline</h3>
<p>By default, <strong>Pipeline</strong> will clean up the <strong>Flow Elements</strong> it contains.
However, there must be an option to disable this behavior.</p>
<p>This is needed for scenarios where single elements are added to multiple
<strong>Pipelines</strong>.
In this case, the user must take responsibility for cleanup of
<strong>Flow Element</strong> resources. This should be made clear in comments and
documentation around the use of this option.</p>
<h3 id="flow-element">Flow Element</h3>
<p><strong>Flow Elements</strong> can be very light-weight, but can also maintain significant
internal resources.</p>
<p>Similar to <strong>Element Data</strong> we have found native resources to be
the primary problem area.</p>
<p>There must be some mechanism to ensure that such resources are cleaned up
when the <strong>Flow Element</strong> is no longer needed.</p>
<p>Whether other <strong>Flow Elements</strong> need any specific cleanup logic is
left up to implementers.</p>
<h3 id="element-data">Element Data</h3>
<p>In general, we have found that specific clean up of resources associated with
<strong>Element Data</strong> instances is not needed as the garbage collector does a good
enough job.
However, there are two caveats to this:</p>
<ol>
<li>This will not be the case in all programming languages. Some profiling should
be done to ensure that cleanup is being done effectively in the absence of
specific cleanup logic.</li>
<li>Where the <strong>Element Data</strong> contains references to native (C/C++) resources
the system needs assistance to tie the cleanup of the <strong>Element Data</strong> to
the cleanup of these native resources. We have found that without this
assistance, the system fails to clean resources up fast enough, leading to
resource starvation and low level memory exceptions.</li>
</ol>
<h4 id="impact-on-caching">Impact on caching</h4>
<p>Where the <a href="caching.md">result caching</a> feature is being used, <strong>Element Data</strong>
instances will be stored in the cache.</p>
<p>If the instances are cleaned up after they are used, then the ones stored in
the cache become useless.</p>
<p>Consequently, the system must not allow a cache to be added to <strong>Engines</strong>
where the <strong>Element Data</strong> they produce requires cleanup beyond what normal
garbage collection will achieve.</p>
<h3 id="flow-data">Flow Data</h3>
<p>Cleanup of <strong>Flow Data</strong> may include any resources that it holds. However,
the primary concern is to ensure that any <strong>Element Data</strong> instances that
it holds that require cleanup are taken care of.</p>
<p><strong>Element Data</strong> instances that do not require cleanup must be left alone
in order for <a href="caching.md">result caching</a> to work correctly.</p>
<p>Note that <strong>Flow Data</strong> holds a reference to the <strong>Pipeline</strong> that created
it. However, <strong>Flow Data</strong> instances are not cleaned up when the <strong>Pipeline</strong>
is cleaned up. As such, it is possible to have active references to
<strong>Flow Data</strong> instances that reference disposed <strong>Pipeline</strong> instances and
would fail if processed.</p>
<p>Ideally, a helpful error message should be thrown in this scenario.</p>

<hr/>
<h1 id="file-system-paths">File system paths</h1>
<p>Where file system paths are supplied as parameters, the Pipeline API MUST
be able to work with relative paths in any form that the user may
reasonably expect to be able to use.</p>
<p>For example, ASP.NET uses a tilde (~) to
<a href="https://www.cryer.co.uk/brian/csharp/tilde_virtual_paths_in_asp_net.htm">signify</a>
the current application&rsquo;s virtual directory.</p>
<p>Therefore, it should be possible for users to supply paths using this
tilde notation for things such as Engine data file locations.</p>

<hr/>
<h1 id="usage-sharing">Usage sharing</h1>
<p>Users of 51Degrees products have the option to send usage data to us.</p>
<p>This process is very important to us, as well as to users, as it is
used to help improve the accuracy of our products.</p>
<p>For example, our Device Detection product relies on usage data from
customers to give us a good view of what user-agents, client-hints, etc
are active in the real world.
This is a constantly evolving picture, so good quality data is
essential.</p>
<p>Data is shared in XML format, with multiple process requests aggregated
to produce each payload.</p>
<p>Shared data includes details such as:
- Evidence values
- <strong>Pipeline</strong> configuration.
- OS, programming language and API versions.</p>
<p>For more technical details, see the
<a href="../pipeline-elements/usage-sharing-element.md">share usage element</a>.</p>

<hr/>
<h1 id="properties">Properties</h1>
<h2 id="overview">Overview</h2>
<p>This document contains details on the features associated with the Properties that
are populated by <strong>Flow Elements</strong>.</p>
<p>In this case, a &lsquo;Property&rsquo; refers to a specific, named data field that can be
set to different values.</p>
<p>The Property value will be determined during the &lsquo;process&rsquo; step that is performed
by each <strong>Flow Element</strong>. This value will be stored within the <strong>Element Data</strong>,
which is in turn stored within <strong>Flow Data</strong>.</p>
<p>Each <strong>Flow Element</strong> may populate values for zero or more Properties.</p>
<h2 id="value-types">Value types</h2>
<p>A Property may return values of any type. However, there are certain types that are
specifically expected and supported throughout the API.</p>
<p>The primary limitation is that it must be possible for these types to be represented
in JSON data.</p>
<p>As such, the core types are:</p>
<ul>
<li>string</li>
<li>boolean</li>
<li>numeric (integer or floating point)</li>
<li>array of strings</li>
</ul>
<p>In addition, there are a couple of types that are supported through additions in
JSON encode/decode logic:</p>
<ul>
<li>javascript - See <a href="#the-javascript-type">the javascript type</a> below</li>
<li>array of key-value-pair collections - Used in scenarios where we want to return
multiple Aspect data instances. (For example, TAC lookup)</li>
</ul>
<h3 id="the-javascript-type">The javascript type</h3>
<p>The javascript type is a custom type that simply represents a string.
It is used to identify values that contain JavaScript snippets that are intended
to be executed on the client device.</p>
<p>See <a href="web-integration.md">web integration</a> for more detail.</p>
<h2 id="null-values">Null values</h2>
<p>Property values populated by <strong>Engines</strong> (as opposed to all <strong>Flow Elements</strong>)
must be capable of having &lsquo;no value&rsquo;.</p>
<p>Where &lsquo;no value&rsquo; is used, attempting to access the value should throw an
error/exception with a customizable message explaining why the value is not set.</p>
<p>This is similar to the <a href="#missing-properties">missing Property</a> feature.
In that case, the Property is not present in the result dataset at all. In this
case, the Property is present in the result. However, the Flow Element has
chosen not to set its value for some reason.</p>
<h2 id="property-metadata">Property metadata</h2>
<p>All <a href="../conceptual-overview.md#flow-element">Flow Elements</a> must expose metadata
describing details of the Properties that they can populate.</p>
<p>In addition, it must be possible to get Property metadata at the <strong>Pipeline</strong>
level for all Properties that can be populated by all <strong>Flow Elements</strong> in the
<strong>Pipeline</strong>.</p>
<p>The table below describes the metadata that is available.</p>
<table>
<thead>
<tr><th> Property                 </th><th> Type                                    </th><th> Description                                                                                                                                                                                                                                                                                                          </th></tr>
</thead>
<tbody>
<tr><td> Name                     </td><td> string                                  </td><td> The name of the Property. This is the string name used to access the Property value in the <a href="../conceptual-overview.md#element-data">Element Data</a>                                                                                                                                                                    </td></tr>
<tr><td> Element                  </td><td> IFlowElement                            </td><td> The <strong>Flow Element</strong> that will populate the value for this Property.                                                                                                                                                                                                                                                 </td></tr>
<tr><td> Category                 </td><td> string                                  </td><td> A string name of the category that this Property belongs to. This is used to help organize Properties for elements that populate large numbers of them.                                                                                                                                                              </td></tr>
<tr><td> Type                     </td><td> Type                                    </td><td> The type of the value returned by the Property                                                                                                                                                                                                                                                                       </td></tr>
<tr><td> Available                </td><td> bool                                    </td><td> Flag used to store whether this Property is currently available to the caller or not. If not, then the Property value will not be present in <strong>Element Data</strong>                                                                                                                                                        </td></tr>
<tr><td> Delay Execution          </td><td> bool                                    </td><td> Flag used to control execution of <a href="#the-javascript-type">JavaScript</a> Properties. See <a href="web-integration.md">web integration</a> for more detail.                                                                                                                                                                          </td></tr>
<tr><td> Evidence Properties      </td><td> List&lt;string&gt;                          </td><td> A list of the string names of any <a href="#the-javascript-type">JavaScript</a> Properties that can be executed to help determine the value of this Property. See <a href="web-integration.md">web integration</a> for more detail.                                                                                                        </td></tr>
<tr><td> Item Properties          </td><td> List&lt;IPropertyMetaData&gt;               </td><td> Some Property values will be a collection of complex objects. In that scenario, this contains the metadata for the Properties on that complex object. Currently, this is only used by the <a href="../../device-detection-specification/pipeline-elements/hardware-profile-lookup-cloud.md">Hardware profile lookup Engine</a> </td></tr>
<tr><td> Item Property Dictionary </td><td> Dictionary&lt;string, IPropertyMetaData&gt; </td><td> The same data returned by &lsquo;Item Properties&rsquo;, but keyed on Property name.                                                                                                                                                                                                                                             </td></tr>
</tbody>
</table>
<h3 id="aspect-property-metadata">Aspect Property metadata</h3>
<p><a href="../conceptual-overview.md#aspect-engine">Aspect Engines</a> are required to populate
some additional metadata values beyond those required for <strong>Flow Elements</strong>.</p>
<p>The table below describes the additional metadata that is available.</p>
<table>
<thead>
<tr><th> Property                 </th><th> Type           </th><th> Description                                                                                                                                                                         </th></tr>
</thead>
<tbody>
<tr><td> Description              </td><td> string         </td><td> A description of the Property                                                                                                                                                       </td></tr>
<tr><td> Data tiers where present </td><td> List&lt;string&gt; </td><td> A list of the string names of the data tiers/files that can be used to populate the value for this Property. This is used by the <a href="#missing-properties">missing Properties</a> feature. </td></tr>
</tbody>
</table>
<h2 id="missing-properties">Missing Properties</h2>
<p>This feature is specific to Properties populated by <strong>Engines</strong> (rather than all
<strong>Flow Elements</strong>).</p>
<p>When the user attempts to access a Property that is defined for an Engine, but
does not exist in the result set for some reason, the system must throw an
error/exception with a message explaining why the Property is not available.</p>
<p>This may be any of the following reasons:</p>
<table>
<thead>
<tr><th> Reason                                  </th><th> Notes           </th><th> Message                                                                                                                                                                                                                                                                                                            </th><th> Parameters                                                                                             </th></tr>
</thead>
<tbody>
<tr><td> Not available in the current data file  </td><td> On-premise only </td><td> Property &lsquo;{0}&rsquo; not found in data for element &lsquo;{1}&rsquo;. This is because your license and/or data file does not include this Property. The Property is available with the {2} license/data.                                                                                                                             </td><td> 0. Property name<br/>1. element name<br/>2. comma-separated list of data file/license types            </td></tr>
<tr><td> Property excluded in configuration      </td><td> On-premise only </td><td> Property &lsquo;{0}&rsquo; not found in data for element &lsquo;{1}&rsquo;. This is because the Property has been excluded when configuring the Engine.                                                                                                                                                                                    </td><td> 0. Property name<br/>1. element name                                                                   </td></tr>
<tr><td> Product not included with Resource Key  </td><td> Cloud only      </td><td> Property &lsquo;{0}&rsquo; not found in data for element &lsquo;{1}&rsquo;. This is because your Resource Key does not include access to any Properties under &lsquo;{2}&rsquo;. For more details on Resource Keys, see our explainer: <a href="https://51degrees.com/documentation/_info__resource_keys.html">https://51degrees.com/documentation/_info__resource_keys.html</a>                                                   </td><td> 0. Property name<br/>1. element name<br/>2. product name                                               </td></tr>
<tr><td> Property not included with Resource Key </td><td> Cloud only      </td><td> Property &lsquo;{0}&rsquo; not found in data for element &lsquo;{1}&rsquo;. This is because your Resource Key does not include access to this Property. Properties that are included for this key under &lsquo;{2}&rsquo; are {3}. For more details on Resource Keys, see our explainer: <a href="https://51degrees.com/documentation/_info__resource_keys.html">https://51degrees.com/documentation/_info__resource_keys.html</a> </td><td> 0. Property name<br/>1. element name<br/>2. product name<br/>3. comma-separated list of Property names </td></tr>
</tbody>
</table>

<hr/>
<h1 id="logging">Logging</h1>
<p>The Pipeline API must implement logging, ideally using a popular third-party
logging library. Whichever library is used, the system should be configurable
without rebuilding binaries and capable of outputting to a log target at a
configurable location.</p>
<p>Ideally, the solution should support logging at multiple levels. This will allow
the customer to configure logging at the level they require and allow 51Degrees
to easily obtain more detailed logs when needed.</p>
<p>An example of the types of messages to assign to different log levels is available
in <a href="https://learn.microsoft.com/dotnet/api/microsoft.extensions.logging.loglevel">Microsoft&rsquo;s documentation</a></p>
<p>Care should be taken to ensure that detailed (e.g. debug level) logging does not
impact performance when it is not enabled.</p>

<hr/>
<h1 id="data-update">Data update</h1>
<h2 id="overview">Overview</h2>
<p>An on-premise <strong>Aspect Engine</strong> may require data that is independent of the
logic of the Engine and that is periodically refreshed. For example,
when new phones or browser versions are released, the Device Detection
Engine will require a new data file in order to detect and populate
Property values for those new cases. The Data Update Service
provides functionality for this.</p>
<p>The Data Update Service assumes that the data is available from an HTTP
endpoint or that it can be provided by means of file store that is accessible
to an instance of the Aspect Engine.</p>
<p>It is possible that an Aspect Engine requires more than one data source [^1] and
implementers may choose either to provide the data in a single unified way
or to implement the Data Update service to allow for multiple file sources.</p>
<p>[^1] data sources are referred to as data files in the reference implementations</p>
<h3 id="aspect-engine-features">Aspect Engine features</h3>
<p>In order to support this feature, <strong>Aspect Engines</strong> must have
some additional abilities:</p>
<ol>
<li>At configuration time, there must be a mechanism for supplying details about
the data sources that the Engine needs along with any information
and configuration options associated with updating it.</li>
<li>The Engine must provide a mechanism to allow it to refresh,
(use an updated data source) on demand.</li>
<li>The mechanism must be thread safe.</li>
</ol>
<p>The Pipeline that contains the Aspect Engine must still be capable of
processing Flow Data with minimal
performance impact while data refresh is happening.</p>
<h2 id="data-refresh-availability">Data refresh availability</h2>
<p>A data source may contain a timestamp that specifies when it was created and may
contain a timestamp that indicates when refreshed data will be available. This
information can be used to optimize polling, or to provide information as to
how up-to-date the current data is.</p>
<h2 id="operational-modes">Operational modes</h2>
<p>From the point of view of the Data Update Service, Aspect Engines have several
operational modes:</p>
<ul>
<li>File Data Source, File Based Operation</li>
<li>File Data Source, Memory Based Operation</li>
<li>Memory Data Source, Memory Based Operation</li>
</ul>
<p>Other operational modes may be possible, such as an Aspect Engine&rsquo;s data residing
in a relational database.</p>
<h3 id="file-data-source-file-based-operation">File data source, file based operation</h3>
<p>In this operational mode an Aspect Engine uses data that
resides in the file system to support its operation. This may be because the
data is too extensive to be loaded into memory or because of memory limitations
in the system.</p>
<h3 id="file-data-source-memory-based-operation">File data source, memory based operation</h3>
<p>In many cases, for reasons of access speed, it is desirable for the data, which
is provided in a file, to be loaded into memory on start-up and on refresh.</p>
<h3 id="memory-data-source">Memory data source</h3>
<p>In some cases, to provide for fully disk-less operation, it may be desirable
for an Aspect Engine to obtain its data
as a memory buffer on start-up and on refresh.</p>
<h2 id="operational-options">Operational options</h2>
<p>A number of options control the operation of the Data Update Service. Not all
options are available in every mode and some combinations of options are
either mutually exclusive or unlikely to be useful. For example, it&rsquo;s unlikely
that an Aspect Engine will be configured with both the ability to update
from a disk based data file and update from HTTP.
Providing for both being active at the same time adds complexity to the
implementation.</p>
<p>Implementations may choose to report an error when inconsistent configuration
options are chosen.</p>
<h3 id="update-on-start-up">Update on start-up</h3>
<p>This option provides for checking for data from an HTTP server on start-up
as a blocking operation.</p>
<p>This option is available both for memory data source mode and for file data
source modes. If the data source provides a timestamp then the remote timestamp
is compared with the local timestamp, and the remote data is used if it is more
recent than the current data.</p>
<p>This option can be used to bootstrap an Aspect Engine that does not yet have
any local data. In the case of file data source, the data is stored once
obtained via HTTP.</p>
<p>Configuration Groups:
- <em>HTTP config</em></p>
<h3 id="automatic-update-via-http">Automatic update via HTTP</h3>
<p>This option provides for periodic ongoing checking of an HTTP server
for the availability of an updated data source.</p>
<p>If the current data contains a <em>data update expected</em> timestamp, then polling
should start after that time. Options include the ability to control the remote
endpoint and the polling frequency.</p>
<p>As an optimization, the request for data may contain an <em>if modified since</em> HTTP
header, containing the date of the current data file.</p>
<p>If data is received that is newer than the current data, then the Aspect Engine
is refreshed with the newly available data. In the case of
file data source operation, the new data replaces
the existing data, at the location configured for data files.</p>
<p>51Degrees download servers have a request rate limiting feature which provides
for a 429 HTTP Status (Too many requests) with a <em>Retry After</em> HTTP header
whose value should be used to reset polling.</p>
<p>Rate limiting may be triggered
in the event that a single user has multiple servers each of which is set to
auto update. It is recommended that users with multiple servers do not use
this feature and that they obtain updated data once and distribute it to their
various servers by other means.</p>
<p>Configuration Groups:
- <em>HTTP config</em>
- <em>Polling config</em>
- <em>Operational file config</em></p>
<h3 id="automatic-update-from-file">Automatic update from File</h3>
<p>This option allows users to obtain new data files by whatever means they choose,
and have the Aspect Engine refresh by detection of a new file in the file system
at the location configured for the data file.</p>
<p>Any timestamp contained in the data source is not taken into consideration,
operation depends on the operational environment reporting file system changes
and whatever file is found is used as the data source for the restarted
Aspect Engine.</p>
<p>If the operational environment does not support file system watching events,
implementors may need to use polling to determine changes and should have
due regard to file system load when setting polling frequency.</p>
<h3 id="programmatic-update">Programmatic update</h3>
<p>The option allows for programmatic triggering of an update. The effect of a
programmatic update is to initiate
immediate polling of the remote HTTP server, where this option is enabled.</p>
<p>If it is automatic update via HTTP is not enabled, for file data sources
it causes immediate update, irrespective of whether Automatic Update
from File is enabled.</p>
<p>For memory data sources programmatic update must allow provision of the new memory data source.</p>
<p>Implementations may choose to provide options of Programmatic Update that
distinguish a request for HTTP update as opposed to file update.</p>
<p>Configuration Groups:
- <em>HTTP config</em>
- <em>Polling config</em>
- <em>Operational file config</em></p>
<h2 id="configuration-groups">Configuration groups</h2>
<h3 id="http-config">HTTP config</h3>
<p>Configuration of the remote endpoint for download:
- <strong>dataUpdateUrl</strong> - the remote URL
- <strong>urlFormatter</strong> - URL customization
- <strong>useIfModifiedSince</strong> - request data using if modified since HTTP header
- <strong>decompressContent</strong> - deprecated - always decompress content if it is compressed
- <strong>verifyMD5</strong> - deprecated - always verify MD5 if an MD5 value is provided</p>
<h3 id="polling-config">Polling config</h3>
<p>Configuration of the frequency for checking of new content:
- <strong>pollingInterval</strong> - frequency of polling of server
- <strong>randomization</strong> - provide a variation of polling frequency to avoid
synchronized requests from more than one server</p>
<h3 id="operational-file-config">Operational file config</h3>
<p>Configuration of the locations that disk based operation is done from:
- <strong>dataSourceFileLocation</strong> - where to load the data source fom
- <strong>createOperationalDataCopy</strong> - create a copy of the data source, for operation
- <strong>operationalDataFileDirectory</strong> - the directory for the data file copy</p>
<p>For disk based operation it is necessary to create an Operational Data Copy [^1] if
auto update via HTTP is enabled or if auto update from file is enabled. This is
to allow continued operation of the Aspect Engine with its present data file
while a new data file is made available.</p>
<p>[^1] This is called <em>tempDataFile</em> in current reference implementations.</p>
<p>Since creating a data file copy is required for disk based operation
implementations may choose not to provide control over
<strong>createOperationalDataCopy</strong> since disallowing it when either update option
is enabled and disk based operation is enabled is an error.</p>
<p>Implementations may choose to report an error if any item
in this configuration is set for memory data source operation.</p>
<h2 id="update-processes">Update processes</h2>
<h3 id="update-on-start-up">Update on start-up</h3>
<ul>
<li>for disk data source, check operational data configuration consistency</li>
<li>check HTTP server for new file</li>
<li>on fail, fall back to local file if any
<ul>
<li>no local file, fail</li>
</ul>
</li>
<li>compare date with local</li>
<li>if newer or there is no local file,
<ul>
<li>save new file</li>
</ul>
</li>
<li>load file</li>
<li>if disk data source, configure file watcher, if requested</li>
<li>configure HTTP update polling, if requested</li>
<li>continue</li>
</ul>
<h3 id="other-start-up">Other start-up</h3>
<ul>
<li>check operational data configuration consistency</li>
<li>load data from memory or file</li>
<li>if disk data source, configure file watcher, if requested</li>
<li>configure HTTP update polling, if requested</li>
<li>continue</li>
</ul>
<h3 id="newbufferavailable-from-memory-via-remote">newBufferAvailable (from memory, via remote)</h3>
<p>Probably can&rsquo;t compare dates so load whatever we have:
- load buffer</p>
<h3 id="newfileavailable-via-remote-or-file-watcher">newFileAvailable (via remote or file watcher)</h3>
<p>The file will be in <strong>dataFilePath</strong> from watcher or from download, if the
downloaded file is newer than the current file
- pause file watcher, if any
- pause update polling, if any
- load file
- resume polling, if any
- resume file watcher, if any
- trigger onUpdateCallbacks</p>
<h3 id="programmatic-update">Programmatic update</h3>
<ul>
<li>poll remote, if polling is configured</li>
<li>check if file is newer
<ul>
<li>if so, process as per newFile above</li>
</ul>
</li>
<li>return</li>
<li>if newer file in <strong>dataFilePath</strong></li>
<li>process as per newFile above</li>
<li>return</li>
</ul>
<h2 id="update-polling">Update polling</h2>
<p>This section making an HTTP request to check for
updated data and handling the response.</p>
<p>51Degrees Device Detection data files are supplied by the
<a href="http://51degrees.com/documentation/_info__distributor.html">Distributor</a>
web API. The capabilities of the data update service align with those of
the Distributor. However, the service must be capable of using other sources
as well. For example, a simple static URL that just supplies a file.</p>
<p>When sending a request to the <em>data update URL</em>, the <code>If-Modified-Since</code>
header should be set to the publication date of the existing data file.
If the data file does not have a publication date then the file system last modified
date/time can be used instead. This ensures that if a new data file has not
been published yet, we won&rsquo;t waste bandwidth downloading it.</p>
<p>There must be some mechanism for the update service to add query parameters
to the data update URL when needed.
The reference implementations use a &lsquo;URL formatter&rsquo; class. Below are the
implementations used for calls made to the Distributor.</p>
<ul>
<li><a href="https://github.com/51Degrees/pipeline-dotnet/blob/master/FiftyOne.Pipeline.Engines.FiftyOne/Data/FiftyOneUrlFormatter.cs">.NET FiftyOneUrlFormatter</a></li>
<li><a href="https://github.com/51Degrees/pipeline-java/blob/master/pipeline.engines.fiftyone/src/main/java/fiftyone/pipeline/engines/fiftyone/data/FiftyOneUrlFormatter.java">Java FiftyOneUrlFormatter</a></li>
</ul>
<p>If a new data file is downloaded, the date of the downloaded data must be
compared with the current file data source, if file data source mode is active.
If the downloaded file is more recent, it replaces the current file data source.</p>
<p>If the data downloaded is more recent or if memory data source mode is in
operation the <strong>Aspect Engine</strong> is refreshed with the new data.</p>
<p>Once the refresh is complete, the data update service can start
checking for updates using the newly refreshed <em>next expected update</em>
date/time.</p>
<p>If no update was found then the service should repeat the same checks
after the <em>polling interval</em> + a random time based on<br />
<em>update time maximum randomization</em> has passed.</p>
<h2 id="logging">Logging</h2>
<p>The data update service is a complex process. As such, it is
essential that detailed logging is
available to help diagnose issues that might arise.</p>
<p>All major actions should be logged at the appropriate level along with
relevant details (e.g. which Engine + data file the update is for)</p>
<h3 id="messages-at-start-up">Messages at start-up</h3>
<table>
<thead>
<tr><th> <strong>Action</strong>                            </th><th> <strong>Message</strong>                  </th></tr>
</thead>
<tbody>
<tr><td> Running the update on start-up process </td><td> Updating on start-up          </td></tr>
<tr><td> File system watcher created           </td><td> Creating file system watcher </td></tr>
</tbody>
</table>
<h3 id="messages-during-operation">Messages during operation</h3>
<table>
<thead>
<tr><th> <strong>Action</strong>                                           </th><th> <strong>Message</strong>                                                                     </th></tr>
</thead>
<tbody>
<tr><td> Starting the check for update process                </td><td> Checking for update                                                             </td></tr>
<tr><td> Call <a href="#aspect-engine-features">refresh</a> on an Engine </td><td> Attempting to refresh Engine &lsquo;&lt;Engine type&gt;&rsquo; with new data                    </td></tr>
<tr><td> Send HTTP request to check for new data file         </td><td> Checking for update from &lsquo;&lt;url&gt;&rsquo; for Engine &lsquo;&lt;Engine type&gt;&rsquo;                 </td></tr>
<tr><td> Successfully downloaded new data file                </td><td> Downloaded new data from &lsquo;&lt;url&gt;&rsquo; for Engine &lsquo;&lt;Engine type&gt;&rsquo;                 </td></tr>
<tr><td> 304 (Not modified) response from HTTP request        </td><td> No data newer than &lt;datetime&gt; found at &lsquo;&lt;url&gt;&rsquo; for Engine &lsquo;&lt;Engine type&gt;&rsquo; </td></tr>
</tbody>
</table>
<h3 id="errors">Errors</h3>
<p>There are several possible causes of errors within the data update service.
As this is a background service, we must ensure that any failures are
caught and logged, rather than being lost or causing process failures.</p>
<p>These messages must also be consistent across languages to make life easier
for 51Degrees support.</p>
<p>[<strong><em>Highlighted</em></strong>] text should only be present if this is an automated update rather
than a procedural update.</p>
<table>
<thead>
<tr><th> <strong>Error</strong>                                                                                                                       </th><th> <strong>Log level</strong> </th><th> <strong>Message</strong>                                                                                                                                                                                  </th></tr>
</thead>
<tbody>
<tr><td> Could not connect to remote server for data file update                                                                         </td><td> Warning       </td><td> An error occurred when connecting to &lt;url&gt; in order to check for data file updates for &lt;Engine type name&gt;. [***Update will be attempted again later.***] Error detail: &lt;error message&gt; </td></tr>
<tr><td> Error downloading file                                                                                                          </td><td> Warning       </td><td> An error occurred while downloading a data file update for &lt;Engine name&gt; from &lt;url&gt;. [***Update will be attempted again later.***] Error detail: &lt;error from distributor&gt;             </td></tr>
<tr><td> Error validating data file                                                                                                      </td><td> Warning       </td><td> An error occurred during the integrity check of new data file for &lt;Engine name&gt;. [***Update will be attempted again later.***] Error detail: &lt;error&gt;                                     </td></tr>
<tr><td> Error writing to <em>data file location</em> or <em>temp file location</em>                                                               </td><td> Error         </td><td> An error occurred when writing to &lt;file path&gt;. Error detail: &lt;error&gt;                                                                                                                     </td></tr>
<tr><td> Engine was built from a file with the use temp file flag disabled. And the file at <em>data file location</em> is currently locked </td><td> Error         </td><td> Unable to update data file. This is probably because the Engine was built with the use temp file option disabled.                                                                          </td></tr>
<tr><td> Error when calling RefreshData on Engine                                                                                        </td><td> Error         </td><td> An error occurred while applying a data file update to &lt;Engine type name&gt;. Error detail: &lt;error&gt;                                                                                         </td></tr>
<tr><td> Attempting to update a data file that has no configured temporary file path                                                     </td><td> Error         </td><td> The data file &lsquo;&lt;data file identifier&gt;&rsquo; is checking for updates but does not have a temporary file path configured.                                                                         </td></tr>
<tr><td> Some file system error occurs while copying a new data file                                                                     </td><td> Error         </td><td> An error occurred when copying a data file to replace the existing one at &lsquo;&lt;path&gt;&rsquo;.                                                                                                        </td></tr>
</tbody>
</table>

<hr/>
<h1 id="advertise-accepted-evidence">Advertise accepted Evidence</h1>
<h2 id="summary">Summary</h2>
<p>All <strong>Flow Elements</strong> and <strong>Pipelines</strong> must be capable of programmatically
describing the Evidence keys that they can make use of.</p>
<h2 id="flow-elements">Flow Elements</h2>
<p>For the majority of <strong>Flow Elements</strong>, simply returning a list of Evidence
values
they can use would be sufficient.
For example, the Device Detection Engine will accept <code>query.user-agent</code>,
<code>header.user-agent</code>, <code>query.sec-ch-ua</code>, <code>header.sec-ch-ua</code>, etc.</p>
<p>However, in some scenarios, a more complex approach is needed.
The main use-case is the share usage element. The data that this element
shares is configurable, but will typically include all HTTP headers (excluding
those known to have personally identifiable information). Consequently, listing
all the header names it will accept is impractical.</p>
<p>It is valid for an element not to make use of any Evidence values at all
(for example, Cloud Aspect Engines - which use the output from the cloud
request Engine)</p>
<h2 id="usage">Usage</h2>
<p>This feature is used to enable or assist with other features.</p>
<ul>
<li><a href="caching.md">caching</a> - cache keys will be generated based on the values of
the Evidence keys that the Engine accepts.</li>
<li><a href="web-integration.md#populating-evidence">web integration</a> - Data from a web
request is automatically added to Evidence.</li>
</ul>

<hr/>
<h1 id="access-to-results">Access to results</h1>
<h2 id="general-guidance">General guidance</h2>
<p>Where string keys are used, the following rules apply:</p>
<ul>
<li>Strings should only contain alphanumeric characters, full stop or hyphen.</li>
<li>Some 51Degrees Properties also use the / character. No new Properties will
be added with this character, but it must be accommodated.</li>
<li>Lower-case is preferred but not required.</li>
<li>String comparisons must be case insensitive.</li>
</ul>
<h2 id="accessing-results">Accessing results</h2>
<p>There are multiple ways to access the results of processing.</p>
<p>Firstly, these are the mechanisms for getting Element Data:</p>
<ol>
<li>It must be possible to get Element Data by supplying the string key
for the element. For example:</li>
</ol>
<pre><code class="language-c#">IElementData deviceData = flowData.Get(DeviceDetectionEngine.ElementDataKey);
</code></pre>
<ol>
<li>In strongly typed languages, it should be possible to get Element Data
instance by supplying the type of the data required. For example:</li>
</ol>
<pre><code class="language-c#">IDeviceData deviceData = flowData.Get&lt;IDeviceData&gt;();
</code></pre>
<ol>
<li>In strongly typed languages, it should be possible to get an Element Data
instance by supplying an element instance.
For example:</li>
</ol>
<pre><code class="language-c#">IDeviceData deviceData = flowData.GetFromElement(deviceDetectionEngine);
</code></pre>
<ol>
<li>In strongly typed languages it may be useful to get the type of
Element Data associated with a Flow Element, without getting an associated
instance. For example:</li>
</ol>
<pre><code class="language-c#">Type deviceDataType = getDataTypeFromElement(deviceDetectionEngine);
</code></pre>
<p>Below are the mechanisms for getting Properties:</p>
<ol>
<li>It must be possible to get a Property value from an Element Data instance by
supplying the string key for that Property. For example:</li>
</ol>
<pre><code class="language-c#">object propertyValue = deviceData.Get(&quot;ismobile&quot;);
</code></pre>
<ol>
<li>It should be possible to get a Property value from an Element Data instance
by using standard Property accessors for the language. For example:</li>
</ol>
<pre><code class="language-c#">IAspectPropertyValue&lt;bool&gt; propertyValue = deviceData.IsMobile;
</code></pre>

<hr/>
<p>All the features described in this section have substantial impacts
on other parts of the API, particularly areas such as
<a href="../features/resource-cleanup.md">resource cleanup</a>
and <a href="../features/thread-safety.md">thread safety</a>.</p>
<p>Most are not implemented in all Pipeline API languages. Either due
to complexity or simply not being possible.</p>
<p>Most also provide questionable benefits to justify this complexity.</p>
<p>Whether these features are implemented or not should be carefully
considered and agreed up front.</p>

<hr/>
<h1 id="lazy-loading">Lazy loading</h1>
<p>This feature is specific to Properties populated by <strong>Engines</strong> (rather than all
<strong>Flow Elements</strong>).
It is currently only implemented in .NET and Java.</p>
<p>There are several execution strategies one might consider for the Process function.
For example:</p>
<ul>
<li>Eager blocking, standard execution</li>
<li>Eager non-blocking, but then request to get the result value blocks</li>
<li>Lazy non-blocking, the computation starts at the point of requesting the result value</li>
<li>Eager asynchronous, that must be awaited (allowing the thread do run loop execution)</li>
</ul>
<p>This feature, as currently implemented, corresponds with the eager, non-blocking
strategy from the list above. This may lead to renaming the feature in future. For
the time being, in order to be consistent, it should be called &lsquo;lazy loading&rsquo;.</p>
<p>This means that &lsquo;process&rsquo; will return immediately. When the user attempts to access
the value of a Property that is populated by this Engine, the call must block until
the background task is complete.</p>
<p>Some languages may have async/await features that may appear to be a good fit for
handling this type of execution in a neater way. There is no rule in this
specification against using such features. However, the implementation will need
to be carefully considered in order to avoid falling into the trap of adding
complexity for little real-world benefit.</p>
<p>Note that there are many scenarios where lazy loading as described here will be
ineffective. This is because several core Flow Elements make use of Properties
populated by previous elements. (For example, Cloud Aspect Engines, JSON builder,
set response headers.)
If one of these elements is in a Pipeline and the Engine that is populating the
value used by the element is configured for lazy loading, then the Engine&rsquo;s
process function will return immediately, but the element that makes use of its
Property value will just need to wait for the background task to finish anyway.</p>

<hr/>
<p>TODO - write this up.</p>
<ul>
<li>Allowing elements to be executed in parallel adds considerable complexity:</li>
<li>Flow Data must be capable of enforcing thread-safe writes to data structures
while also maintaining performance when it is not needed (which seems to be
majority of installations)</li>
<li>Additional options available during configuration.</li>
<li>More features to document and test.</li>
<li>Many elements have dependencies on each other&rsquo;s output so cannot be executed
in parallel anyway.</li>
<li>The end-to-end processing time is still limited by the slowest element. If
this takes a significant proportion of the total processing time then the
performance benefit will be marginal.</li>
<li>If users want to improve performance through concurrent processing, they can
do so more effectively by creating Flow Data instances on separate threads and
calling process. This is exactly what web servers are doing.</li>
</ul>

<hr/>
<h1 id="process-cancellation">Process cancellation</h1>
<p>Where the language allows, the Pipeline should support a mechanism for the
caller to cancel processing. This will:</p>
<ol>
<li>Where possible - cancel processing for any elements that are currently executing.</li>
<li>Skip processing for any elements that have not yet started.</li>
</ol>
<p>Note that a Flow Data instance that has had processing cancelled may be
missing data that would normally have been populated.</p>
<p>The ability to cancel processing implies that the processing takes place
on some background thread. However, the call to <code>flowdata.Process</code> is blocking
unless a feature such as <a href="lazy-loading.md">lazy loading</a> is being used.</p>
<p>To make it clear that the function is non-blocking when a cancellation token
is supplied, we suggest considering a differently named function for that scenario.
(For example, &lsquo;ProcessAsync&rsquo;).</p>

<hr/>
<h1 id="multi-pipeline-elements">Multi-Pipeline elements</h1>
<p>It should be possible for a <strong>Flow Element</strong> to be added to multiple
<strong>Pipelines</strong> once it has been created.</p>
<p>The intention is that this can be used to allow users to create Pipelines
that only do as much processing as they need for different use cases within
a single system.
Without this feature, new <strong>Flow Element</strong> instances, which may come with
a significant memory footprint, would be required for each <strong>Pipeline</strong>.</p>
<p>This causes difficulties for any <strong>Flow Elements</strong> that maintain some
state information relating to the <strong>Pipeline</strong> they are added to (For
example, <a href="../pipeline-elements/json-builder.md">JSON builder</a>).</p>
<p>If this feature is enabled, then all <strong>Flow Elements</strong> that maintain any
such state information must ensure that they have the means to keep track of
isolated instances of this state for each <strong>Pipeline</strong> to which they are
added and use the correct state information when processing.</p>
<p>Note that is may be preferable for some elements to throw an error if added
to a second Pipeline, rather than implement the logic that would be required
to allow operation in multiple Pipelines. This approach should ideally only
be taken if the element has a very low memory footprint.</p>

<hr/>
<h1 id="sequence-element">Sequence Element</h1>
<h2 id="overview">Overview</h2>
<p>The Sequence Element is used to keep track of the number of times that
the script produced by the <a href="javascript-builder.md">JavaScript Builder Element</a>
makes callbacks to the server.</p>
<p>The generated &lsquo;session id&rsquo; is also used as a key in various places.</p>
<p>Note that in this context, &lsquo;session&rsquo; is not necessarily a one to one
mapping to an HTTP session.</p>
<h2 id="accepted-evidence">Accepted Evidence</h2>
<ul>
<li>query.session-id</li>
<li>query.sequence</li>
</ul>
<h2 id="element-data">Element Data</h2>
<table>
<thead>
<tr><th> <strong>Name</strong>   </th><th> <strong>Type</strong> </th><th> <strong>Description</strong>                                                                       </th></tr>
</thead>
<tbody>
<tr><td> session-id </td><td> string   </td><td> An identifier for this session.                                                       </td></tr>
<tr><td> sequence   </td><td> int      </td><td> A counter that records how many consecutive callbacks have been made in this session. </td></tr>
</tbody>
</table>
<h2 id="process">Process</h2>
<p>If <code>query.session-id</code> is not present in Evidence then generate a new id and
add it to the output. The reference implementations use a GUID.</p>
<p>If <code>query.sequence</code> is present in Evidence then add one to it and add it to
the output. If it is not present, set the output value for sequence to one.</p>
<p>Note that the reference implementations currently write these output values
back to the Evidence collection as Evidence is not implemented as
immutable in the reference implementations.</p>
<h2 id="configuration-options">Configuration options</h2>
<p>None</p>

<hr/>
<h1 id="javascript-builder-element">JavaScript Builder Element</h1>
<h2 id="overview">Overview</h2>
<p>The JavaScript Builder Element takes the JSON output from the
<a href="json-builder.md">JSON Builder Element</a> and merges it into a
template which contains JavaScript.</p>
<p>The resulting JavaScript is provided to the client as part of an HTTP response.
At the client it provides the
following features:</p>
<ul>
<li>Allow access to Pipeline processing results in client-side JavaScript.</li>
<li>Acquire additional Evidence that is only accessible to client-side
JavaScript. This is described in more detail in our
<a href="https://51degrees.com/documentation/_features__client_side_evidence.html">documentation</a></li>
</ul>
<h2 id="accepted-evidence">Accepted Evidence</h2>
<ul>
<li>header.host</li>
<li>header.protocol</li>
<li>query.fod-js-object-name</li>
</ul>
<h2 id="start-up-activity">Start-up activity</h2>
<p>On start-up, initialize the normal data structures, such as
accepted Evidence, and perform any set-up for the template system to
operate as efficiently as possible.</p>
<h2 id="element-data">Element Data</h2>
<table>
<thead>
<tr><th> <strong>Name</strong>   </th><th> <strong>Type</strong> </th><th> <strong>Description</strong>                              </th></tr>
</thead>
<tbody>
<tr><td> javascript </td><td> string   </td><td> The raw JavaScript produced by this Element. </td></tr>
</tbody>
</table>
<h2 id="process">Process</h2>
<p>Determine several values to be passed to the template:</p>
<ol>
<li>If protocol was not specified in configuration, get it from the
<code>header.protocol</code> Evidence value. If that header is not present, then
default to <code>HTTPS</code>.</li>
<li>If host was not specified in the configuration, get it from the
<code>header.host</code> Evidence value.</li>
<li>Get object name from the <code>query.fod-js-object-name</code> Evidence value.
If its not present or blank, use the value specified in the configuration.</li>
<li>Retrieve the Element Data for <a href="json-builder.md">JSON builder element</a> from
the Flow Data. This contains the JSON to be passed to the template.</li>
<li>Retrieve the Element Data for <a href="sequence-element.md">Sequence Element</a> from
the Flow Data. This contains the session id and sequence number to be
passed to the template.</li>
<li>If protocol, host and endpoint are all set, then generate a URL in the
following format: <code>[protocol]://[host][endpoint]</code>. Ensure that values
with/without slashes are handled correctly.</li>
<li>The JavaScript may need to make call backs to the server. A list of any
query parameters that should be included in those calls needs to be created.
This can be done by looking at the query entries in the existing Evidence:</li>
</ol>
<ul>
<li>Get all Evidence values starting with <code>query.</code></li>
<li>Use the text after <code>query.</code> as the key.</li>
<li>Pass keys and values in the form required by the template (don&rsquo;t forget
URL encoding, etc. if needed).</li>
</ul>
<p>These values are applied to the template.</p>
<p>The <a href="https://mustache.github.io/">Mustache</a> template used by reference implementations is available at
<a href="https://github.com/51Degrees/pipeline-dotnet/blob/master/FiftyOne.Pipeline.Elements/FiftyOne.Pipeline.JavaScriptBuilderElement/Templates/JavaScriptResource.mustache">GitHub</a>
There is no requirement that this template or Mustache is used. However,
any new variant would need to reproduce the capabilities of the existing script.</p>
<p>The parameters to the existing template are:</p>
<table>
<thead>
<tr><th> *<strong>Parameter</strong>         </th><th> <strong>Populated from</strong>                                                                          </th><th> <strong>Description</strong>                                                                                                                          </th></tr>
</thead>
<tbody>
<tr><td> _objName              </td><td> Item 3 above                                                                                </td><td> The name of the global JavaScript object to create.                                                                                      </td></tr>
<tr><td> _jsonObject           </td><td> Item 4 above                                                                                </td><td> The string containing the JSON data object.                                                                                              </td></tr>
<tr><td> _sessionId            </td><td> Item 5 above                                                                                </td><td> The session id is used to deduplicate requests when using the JavaScript include                                                         </td></tr>
<tr><td> _sequence             </td><td> Item 5 above                                                                                </td><td> The sequence is the number of calls made by the Session ID                                                                               </td></tr>
<tr><td> _supportsPromises     </td><td> False. Unless Device Detection is in the Pipeline and the Promise Property returns Full </td><td> If true, the script will use Promises                                                                                                    </td></tr>
<tr><td> _url                  </td><td> Item 6 above                                                                                </td><td> The callback url to use when javascript Properties are executed on the client-side.                                                      </td></tr>
<tr><td> _parameters           </td><td> Item 7 above                                                                                </td><td> Any query parameters in Evidence, these should be relayed in callbacks to the cloud service.                                            </td></tr>
<tr><td> _enableCookies        </td><td> From configuration                                                                          </td><td> If false, the script will automatically delete any cookies prefixed with <code>51D_</code> after evaluating Properties.                             </td></tr>
<tr><td> _updateEnabled        </td><td> Should be true if _url is set                                                              </td><td> If true, the JavaScript will include functionality to make callbacks to the server after evaluating JavaScript Properties.               </td></tr>
<tr><td> _hasDelayedProperties </td><td> True if the JSON contains the text <code>delayexecution</code>                                         </td><td> If true, the JavaScript will include functionality to support Properties where execution of the JavaScript will be delayed until needed. </td></tr>
</tbody>
</table>
<p>Finally, the resulting JavaScript can optionally be minified, based on the
configuration provided. If minification is desired, a third-party library should
be used.</p>
<p>Performance tests MUST be in place to verify that this feature has minimal
performance impact. If it does have a significant impact, and no alternative
libraries offer better performance, a cut-down minification process should be
implemented in order to achieve the major benefits without a significant
performance cost.</p>
<h3 id="javascript-template-functionality">JavaScript template functionality</h3>
<p>The JavaScript snippet that is produced by this element must include the
following functionality:</p>
<ul>
<li>A new JavaScript object with a configurable name created in global
scope. This is the mechanism through which the
client-side functionality can be used.</li>
<li>A way to access the results of processing in client-side JavaScript.</li>
</ul>
<h4 id="session-storage-caching">Session storage caching</h4>
<p>As explained in<br />
<a href="../../part2/features/web-integration.md#client-side-caching">web integration</a>,
caching SHOULD be used to reduce the need to resend data.</p>
<p>Since the response to the server is a POST request and
<a href="../../part2/features/web-integration.md#storing-results-of-post-requests">is not cached</a>,
the generated JavaScript must
include functionality to retain results of previous JSON endpoint requests
in session storage on the browser. These are stored using a key created
by combining the session ID and sequence number generated by the
<a href="sequence-element.md">Sequence Element</a>.</p>
<p>Session ID is retained for the lifetime of the session, a future request
to the JSON endpoint with the same session ID and sequence number
as a previous result can be retrieved from session storage.</p>
<h2 id="configuration-options">Configuration options</h2>
<table>
<thead>
<tr><th> <strong>Name</strong>         </th><th> <strong>Type</strong> </th><th> <strong>Default</strong>    </th><th> <strong>Description</strong>                                                                                                                                                                                               </th></tr>
</thead>
<tbody>
<tr><td> SetProtocol      </td><td> String   </td><td> [Empty string] </td><td> The protocol used to make a request once additional Evidence is available from client-side execution. Uses the value from Evidence by default                                                                 </td></tr>
<tr><td> SetHost          </td><td> String   </td><td> [Empty string] </td><td> The host used to make a request once additional Evidence is available from client-side execution. Uses the value from Evidence by default.                                                                    </td></tr>
<tr><td> SetEndpoint      </td><td> string   </td><td> [Empty string] </td><td> The endpoint that a request will be sent to once additional Evidence is available from client-side execution. This endpoint must return JSON data in the same form as the JSON embedded within the JavaScript </td></tr>
<tr><td> SetObjectName    </td><td> String   </td><td> fod            </td><td> The name of the JavaScript object created in the global scope on the client                                                                                                                                   </td></tr>
<tr><td> SetMinify        </td><td> Bool     </td><td> True           </td><td> Enable or disable minification of the Javascript that is produced                                                                                                                                             </td></tr>
<tr><td> SetEnableCookies </td><td> Bool     </td><td> True           </td><td> True if results of client-side processing should be retained in cookies so that they are sent by default in subsequent requests                                                                               </td></tr>
</tbody>
</table>

<hr/>
<h1 id="json-builder-element">JSON Builder Element</h1>
<h2 id="overview">Overview</h2>
<p>The JSON Builder Element creates a JSON representation of most of the values
in the Flow Data.</p>
<p>This is used along with the <a href="javascript-builder.md">JavaScript builder element</a>
and <a href="sequence-element.md">Sequence Element</a> to enable client-side features of
the Pipeline <a href="../../features/web-integration.md">web integration</a>.</p>
<h2 id="accepted-evidence">Accepted Evidence</h2>
<p>This Element uses no Evidence, its only input is the current set of
Element Data instances in the Flow Data.</p>
<h2 id="start-up-activity">Start-up activity</h2>
<p>For performance reasons, on start-up it may be important to create lists of
Property metadata that meet certain criteria.</p>
<p>For example, a list of all Properties that have the &lsquo;delay execution&rsquo; flag set.
Or, for each Property, a list of the JavaScript Properties that can cause their
value to be updated due to new Evidence.</p>
<p>Note that &lsquo;new Evidence&rsquo; in this case refers to Evidence values that are made
available in second or subsequent requests as part of the same &lsquo;session&rsquo;.
These values can then be used to determine or refine results.</p>
<p>See the <a href="https://github.com/51Degrees/pipeline-dotnet/blob/master/FiftyOne.Pipeline.Elements/FiftyOne.Pipeline.JsonBuilderElement/FlowElement/JsonBuilderElement.cs#L715"><code>PopulateMetaDataCollections</code></a>
method in C# for an example of creating these lists.</p>
<h2 id="element-data">Element Data</h2>
<table>
<thead>
<tr><th> <strong>Name</strong> </th><th> <strong>Type</strong> </th><th> <strong>Description</strong>                        </th></tr>
</thead>
<tbody>
<tr><td> JSON     </td><td> string   </td><td> The raw JSON produced by this element. </td></tr>
</tbody>
</table>
<h2 id="process">Process</h2>
<p>The Element needs to produce a JSON representation of the Flow Data.
There should be a top-level entry for each Element Data containing sub-entries
for each Property and its value (set to &lsquo;null&rsquo; if there is no value).</p>
<p>There are also several metadata Properties with different suffixes that may
be added for each Property:</p>
<table>
<thead>
<tr><th> <strong>Suffix</strong>         </th><th> <strong>Description</strong>                                                                                                                                                                                                                                                                              </th></tr>
</thead>
<tbody>
<tr><td> nullreason         </td><td> Where the Property value is null, this meta-Property must be added with a string message that explains why this Property does not have a value.                                                                                                                                              </td></tr>
<tr><td> delayexecution     </td><td> This meta-Property must be added with the value &lsquo;true&rsquo; for all Properties where the <a href="../../features/properties.md#property-metadata">metadata</a> delay execution flag is true.                                                                                                                </td></tr>
<tr><td> EvidenceProperties </td><td> Where the JSON includes other Properties that are in the <a href="../../features/properties.md#property-metadata">metadata</a> Evidence Properties list for this Property and those Properties have the delayed execution flag set to true, this meta-Property must be added to list those Properties. </td></tr>
</tbody>
</table>
<p>Some Elements should be excluded from having their Properties added to the JSON.
These are:
- <a href="set-headers-element.md">Set Headers Element</a>
- <a href="cloud-request-engine.md">Cloud Request Engine</a>
- <a href="usage-sharing-element.md">Usage sharing element</a></p>
<p>The following top-level entries that may be populated in the
final JSON output:
- If the sequence number set by the <a href="sequence-element.md">Sequence Element</a> is less
than the maximum (specified by a constant set to 10 in the reference implementations)
then get a list of the complete names of all JavaScript Properties. Add this to the
result under the top-level key <code>javascriptProperties</code>.
- Add any errors from the Flow Data errors collection to the result. This is structured
as a string array of the error messages under the top-level key <code>errors</code>.</p>
<h3 id="examples">Examples</h3>
<p>Device Detection result including some javascript Properties.
Note the <code>screenpixelswidth</code> Property is currently zero because device
detection does not know how wide the screen is.
The <code>screenpixelswidthjavascript</code> Property contains the JavaScript snippet that
can be executed to gather this information.</p>
<pre><code class="language-json">{
  &quot;device&quot;: {
    &quot;ismobile&quot;: false,
    &quot;screenpixelswidth&quot;: 0,
    &quot;screenpixelswidthjavascript&quot;: &quot;//Set screen pixels width cookie.\r\ndocument.cookie = \&quot;51D_ScreenPixelsWidth=\&quot; + screen.width;&quot;
  },
  &quot;javascriptProperties&quot;: [
    &quot;device.screenpixelswidthjavascript&quot;
  ]
}
</code></pre>
<p>Result from a location lookup before any coordinates have been supplied.
- The <code>javascript</code> Property contains the script to be executed to get the
coordinate values.
- The <code>javascriptdelayexecution</code> Property indicates that we don&rsquo;t want the
<code>javascript</code> snippet to be executed immediately because it will prompt
the user to allow their location to be read.
- The <code>zipcode</code> Property is null because we haven&rsquo;t yet supplied coordinates
- The <code>zipcodenullreason</code> Property contains a description of why <code>zipcode</code>
is null
- The <code>zipcodeevidenceproperties</code> Property contains a list of the delayed
execution Properties that could be executed in order to get a value for
this Property.</p>
<pre><code class="language-json">{
  &quot;location&quot;: {
    &quot;javascript&quot;: &quot;\r\nif (navigator.geolocation) {\r\n\tnavigator.geolocation.getCurrentPosition(function(pos) {\r\n        for (var key in pos.coords) {\r\n            document.cookie = \&quot;51D_Pos_\&quot; + key + \&quot;=\&quot; + pos.coords[key];\r\n        }\r\n        // 51D replace this comment with callback function.\r\n\t}, function(e) {\r\n        document.cookie =\&quot;51D_Pos_Error=\&quot; + encodeURIComponent(e.message);\r\n        // 51D replace this comment with callback function.\r\n    });\r\n}\r\n&quot;,
    &quot;javascriptdelayexecution&quot;: true,
    &quot;zipcode&quot;: null,
    &quot;zipcodenullreason&quot;: &quot;This property requires evidence values from JavaScript running on the client. It cannot be populated until a future request is made that contains this additional data.&quot;,
    &quot;zipcodeevidenceproperties&quot;: [&quot;location.javascript&quot;]
  },
  &quot;javascriptProperties&quot;: [
    &quot;location.javascript&quot;
  ]
}

</code></pre>
<p>Partial result from a TAC lookup that returns multiple devices.</p>
<pre><code class="language-json">{
  &quot;hardware&quot;: {
    &quot;profiles&quot;: [
      {
        &quot;hardwaremodel&quot;: &quot;5217&quot;,
        &quot;hardwarename&quot;: [
          &quot;5217&quot;
        ],
        &quot;hardwarevendor&quot;: &quot;Coolpad&quot;
      },
      {      
        &quot;hardwaremodel&quot;: &quot;5200&quot;,
        &quot;hardwarename&quot;: [
          &quot;5200&quot;
        ],
        &quot;hardwarevendor&quot;: &quot;Coolpad&quot;
      },
      {
        &quot;hardwaremodel&quot;: &quot;5310&quot;,
        &quot;hardwarename&quot;: [
          &quot;5310&quot;
        ],
        &quot;hardwarevendor&quot;: &quot;Coolpad&quot;
      }
    ]
  }
}
</code></pre>
<p>JSON with an error value set.</p>
<pre><code class="language-json">{ 
  &quot;errors&quot;: [ &quot;'abc' is not a valid Resource Key. See http://51degrees.com/documentation/_info__error_messages.html#Resource_key_not_valid for more information.&quot; ]
}
</code></pre>
<h2 id="configuration-options">Configuration options</h2>
<table>
<thead>
<tr><th> <strong>Name</strong>      </th><th> <strong>Type</strong>        </th><th> <strong>Default</strong>  </th><th> <strong>Description</strong>                                                                                                                                                                                                                                                                                                       </th></tr>
</thead>
<tbody>
<tr><td> SetProperties </td><td> List of strings </td><td> [Empty list] </td><td> A list of the Properties to include in the JSON. By default, all Properties will be included. Also note that some Properties, such as JavaScript Properties, will always be included, regardless of this setting. Property names must be fully qualified. (e.g. <code>device.ismobile</code> or <code>devices.profiles.hardwarename</code>) </td></tr>
</tbody>
</table>

<hr/>
<h1 id="cloud-request-engine">Cloud Request Engine</h1>
<h2 id="overview">Overview</h2>
<p>Cloud Engines offload their processing to a remote system. This reduces
resource requirements and avoids the complexities of some local
Engines (For example,
<a href="../../device-detection-specification/pipeline-elements/device-detection-on-premise.md">Device Detection on premise</a>
has a native component that requires additional dependencies)</p>
<p>The Pipeline API splits this cloud processing over two separate types of
Engine:
- Cloud Request Engine - The subject of this section, makes an HTTP
call to a remote service and makes a raw JSON response available
by adding it to its Aspect Data.
- <a href="cloud-aspect-engine.md">Cloud Aspect Engine</a> - Designed to be swapped
out with an equivalent On-premise Engine. Takes the raw JSON response
from the Cloud Request Engine&rsquo;s Aspect Data and deserializes it to
populate its own Aspect Data, which is interface compatible
with the Aspect Data from the On-premise Engine.</p>
<p>The following diagram illustrates this process with a Device Detection
Cloud Engine:</p>
<p><img src="../../../pipeline-specification/images/Device%20Detection%20Cloud%20Engine.png" alt="Cloud Engine flow" /></p>
<p>A Pipeline will usually have a single Cloud Request Engine, but may have
multiple Cloud Aspect Engines - for example, a Location Cloud Engine,
Device Detection Cloud Engine, etc.</p>
<p>This approach is taken in order to allow Cloud Engines to behave as
similarly as possible to On-premise Engines from the user point of view,
while limiting the number of HTTP requests to the same remote
server to one per Flow Data, regardless
of the number of different Aspects required.</p>
<h3 id="resource-key">Resource Key</h3>
<p>A Resource Key is a token that serves both to authenticate a request to the
remote server and to specify which Property values are returned in the
result. Resource Keys are created using the
<a href="https://51degrees.com/documentation/_concepts__configurator.html">51Degrees Configurator</a>.
See <a href="https://51degrees.com/documentation/_info__resource_keys.html">Resource Key Documentation</a>
for more information.</p>
<h2 id="accepted-evidence">Accepted Evidence</h2>
<p>Accepted Evidence is dependent on the supplied Resource Key.</p>
<p><a href="#startup-activity">On start-up</a>, the Engine must make a request to its
remote server
to get this information.</p>
<h2 id="element-data">Element Data</h2>
<table>
<thead>
<tr><th> <strong>Name</strong>      </th><th> <strong>Type</strong> </th><th> <strong>Description</strong>                                   </th></tr>
</thead>
<tbody>
<tr><td> json-response </td><td> string   </td><td> The raw JSON response body from the HTTP request. </td></tr>
</tbody>
</table>
<p>An example of the JSON response received from the server:</p>
<pre><code class="language-json">{
  &quot;device&quot;: {
    &quot;hardwarevendor&quot;: &quot;Apple&quot;,
    &quot;hardwaremodel&quot;: &quot;iPhone 14 Pro Max&quot;,
    &quot;hardwarename&quot;: [
      &quot;iPhone 14 Pro Max&quot;
    ],
    &quot;platformvendor&quot;: &quot;Apple&quot;,
    &quot;platformname&quot;: &quot;macOS&quot;,
    &quot;platformversion&quot;: &quot;Unknown&quot;,
    &quot;iscrawler&quot;: false,
    &quot;javascripthardwareprofile&quot;: null,
    &quot;javascripthardwareprofilenullreason&quot;: null,
    &quot;devicetype&quot;: &quot;SmartPhone&quot;,
    &quot;setheaderbrowseraccept-ch&quot;: &quot;Sec-CH-UA,Sec-CH-UA-Full-Version-List,Sec-CH-UA-Mobile,Sec-CH-UA-Platform&quot;,
    &quot;setheaderhardwareaccept-ch&quot;: &quot;Sec-CH-UA-Model,Sec-CH-UA-Mobile&quot;,
    &quot;setheaderplatformaccept-ch&quot;: &quot;Sec-CH-UA-Platform,Sec-CH-UA-Platform-Version&quot;
  },
  &quot;javascriptProperties&quot;: [
    &quot;device.javascripthardwareprofile&quot;
  ],
  &quot;warnings&quot;: [
    &quot;Low entropy client-hints were supplied in the evidence, but high-entropy client-hints were not.\nThis will lead to less accurate results, and indicates that permissions were not set correctly in the original response to the browser.\nFor more info on client-hint permissions, see http://51degrees.me/documentation/_device_detection__features__user_agent_client_hints.html.&quot;
  ]
}
</code></pre>
<h2 id="start-up-activity">Start-up activity</h2>
<p>On start-up, the Engine must call its configured <code>accessibleproperties</code>
and <code>evidencekeys</code>
endpoints, using the configured Resource Key.</p>
<p>The result from <code>accessibleproperties</code> will be used to populate a publicly
accessible (read only) dictionary containing details of the data and
Properties that are expected to be returned by the cloud service for this
Resource Key.</p>
<p>This information will then be used by <a href="cloud-aspect-engine.md">Cloud Aspect Engines</a>
to populate their Property metadata collections.</p>
<p>The result from <code>evidencekeys</code> will be used to populate the
<a href="#accepted-evidence">accepted Evidence</a> for this Engine.</p>
<p>If either of these requests fails, the Engine MUST throw a critical
error as the Pipeline will be unable to function correctly.</p>
<p>See <a href="#http-requests">HTTP requests</a> for details on general
HTTP request handling.</p>
<h2 id="processing">Processing</h2>
<p>The Engine processes Flow Data by filtering the Evidence provided to that
required by the server, and makes an HTTP
request to the server using the filtered Evidence. The HTTP API used for access to
51Degrees servers is defined at <a href="https://cloud.51degrees.com/api-docs/index.html">https://cloud.51degrees.com/api-docs/index.html</a>.</p>
<p>The server can handle Evidence in a number of different forms, but where
possible, URL-encoded form data should be used. This is constructed
by adding the Resource Key value using the key <code>resource</code>, then adding
all the values from the Flow Data Evidence.</p>
<p>When Evidence is added, its prefix MUST be removed.
For example, <code>query.user-agent</code> becomes <code>user-agent</code>.
This means that conflicts can occur when there are Evidence values for the same
key with different prefixes. Where there are conflicts, the precedence order
defined in <a href="../features/evidence.md">Evidence</a> must be used to
determine which value to use.</p>
<p>See <a href="#http-requests">HTTP requests</a> for details on general
HTTP request handling.</p>
<h2 id="http-requests">HTTP requests</h2>
<p>When making requests to the cloud service during start-up or processing, some
common steps must be followed.</p>
<p>Firstly, the <code>Origin</code> HTTP Header must be set using the configured
<a href="#configuration-options">CloudRequestOrigin</a>.</p>
<p>Second, there are several scenarios that MUST cause an error to be thrown:</p>
<ul>
<li>The response will be a JSON object. A check must be made for an array under a
top-level Property called <code>errors</code>. If this contains an entry then it must be
extracted and the text
used as the message for the thrown error. (If there are multiple entries
then a language-appropriate structure, such as the C# AggregateException
SHOULD be used)</li>
<li>If the response is empty then the message must be
<code>No data in response from cloud service at '[url]'</code></li>
<li>If the HTTP status code indicates failure (i.e. not 200) AND there are no
error messages for the reasons mentioned above, the message must be
<code>Cloud service at '[url]' returned status code '[code]' with content [raw response]</code></li>
</ul>
<p>Similarly to the <code>errors</code> array, any entries in the <code>warnings</code> array in the
response SHOULD be logged as warnings.</p>
<h2 id="configuration-options">Configuration options</h2>
<p>These are the configuration options that are unique to this Engine. They
are in addition to all the configuration options defined for other features.
For example,
<a href="../../../pipeline-specification/part2/features/caching.md">caching</a></p>
<table>
<thead>
<tr><th> <strong>Name</strong>             </th><th> <strong>Type</strong> </th><th> <strong>Default</strong>                                             </th><th> <strong>Description</strong>                                                                                                                                                                           </th></tr>
</thead>
<tbody>
<tr><td> EndPoint             </td><td> string   </td><td> <a href="https://cloud.51degrees.com/api/v4/">https://cloud.51degrees.com/api/v4/</a>                     </td><td> The base URL for the cloud service. This will be suffixed with <code>json</code>, <code>accessibleproperties</code> or <code>evidencekeys</code> to form the complete URLs for the various endpoints called by the Engine. </td></tr>
<tr><td> DataEndPoint         </td><td> string   </td><td> <a href="https://cloud.51degrees.com/api/v4/JSON">https://cloud.51degrees.com/api/v4/JSON</a>                 </td><td> The URL for the cloud service data end point                                                                                                                                              </td></tr>
<tr><td> PropertiesEndPoint   </td><td> string   </td><td> <a href="https://cloud.51degrees.com/api/v4/accessibleProperties">https://cloud.51degrees.com/api/v4/accessibleProperties</a> </td><td> The URL for the cloud service Properties end point                                                                                                                                        </td></tr>
<tr><td> EvidenceKeysEndPoint </td><td> string   </td><td> <a href="https://cloud.51degrees.com/api/v4/Evidencekeys">https://cloud.51degrees.com/api/v4/Evidencekeys</a>         </td><td> The URL for the cloud service Evidence keys end point                                                                                                                                     </td></tr>
<tr><td> ResourceKey          </td><td> string   </td><td> null                                                    </td><td> The Resource Key to use when making requests to the cloud service                                                                                                                         </td></tr>
<tr><td> TimeoutSeconds       </td><td> integer  </td><td> 100                                                     </td><td> The timeout to use when making requests to the cloud service                                                                                                                              </td></tr>
<tr><td> CloudRequestOrigin   </td><td> string   </td><td> null                                                    </td><td> The value to set the &lsquo;Origin&rsquo; header to when making requests to the cloud service                                                                                                         </td></tr>
</tbody>
</table>

<hr/>
<h1 id="cloud-aspect-engine">Cloud Aspect Engine</h1>
<h2 id="overview">Overview</h2>
<p>A Cloud Aspect Engine is a type of Engine that works with the
<a href="cloud-request-engine.md#overview">Cloud Request Engine</a> to enable users
to refer processing of Evidence to a remote server.</p>
<p>See the link above for an overview of how these Engines work together.</p>
<h2 id="accepted-evidence">Accepted Evidence</h2>
<p>Cloud Aspect Engines do not use any Evidence values, they just consume
the output from the Cloud Request Engine.</p>
<h2 id="element-data">Element Data</h2>
<p>The Element Data definition will be different for each Cloud Aspect Engine.
The key requirement is that the Element Data for a Cloud Aspect Engine MUST
be interface compatible with the Element Data for the equivalent on-premise
Engine.</p>
<p>For example, both cloud and on-premise Device Detection Engines in C#
produce an Element Data that implements <code>IDeviceData</code>.</p>
<h2 id="start-up-activity">Start-up activity</h2>
<p>Cloud Aspect Engines do not intrinsically contain Property metadata, they
derive that from the Cloud Request Engine that precedes them in
the Pipeline.</p>
<p>The Cloud Request Engine <a href="cloud-request-engine.md#start-up-activity">requests</a>
this information on start-up. Each Cloud Aspect Engine accesses that
data to obtain Property metadata relating to the Properties that it populates.</p>
<h2 id="processing">Processing</h2>
<p>The precise processing that occurs depends on the Aspect this
Engine relates to.</p>
<p>In outline, the process is:</p>
<ol>
<li>Get the portion of the raw JSON (provided by the Cloud Request Engine as its
Element Data) that relates to this Aspect by using a
string data key. (For example, <code>device</code> for Device Detection)</li>
<li>Use that portion of the raw JSON to construct the Element Data result.</li>
</ol>
<p>The primary difficulty with this process is usually converting from the JSON
format to whatever structure is needed to support the
<a href="../../features/properties.md#null-values">Null Values</a> feature.</p>
<p>For example, in C#, this feature is implemented with the <code>AspectPropertyValue</code>
type. Each value in the JSON is a simple raw string/numeric/boolean value, so
there needs to be logic to:</p>
<ol>
<li>Determine the generic <code>AspectPropertyValue</code> type that is needed.</li>
<li>Create an instance of that type.</li>
<li>Populate the instance with the value from the raw JSON.</li>
<li>If there is no value in the JSON, Look for a JSON Property with the same
name suffixed with <code>nullreason</code>. Use this value to set the <code>NoValueMessage</code>
on the instance.</li>
</ol>
<h2 id="configuration-options">Configuration options</h2>
<p>There are no configuration options for this Engine.</p>

<hr/>
<h1 id="set-headers-element">Set Headers Element</h1>
<h2 id="overview">Overview</h2>
<p>The Set Headers Element constructs a list of all the HTTP response
header values that are required to be set by other Elements in the Pipeline.
Usually, this is done in order to request more Evidence from the
client (For example <a href="http://51degrees.com/documentation/_device_detection__features__u_a_c_h__headers.html">User-Agent Client Hints</a>).</p>
<p>This relies on a Property naming convention whereby any Property
values containing data that should be sent in a response header
are named according to the following format:</p>
<p><code>SetHeader[Identifier][HeaderName]</code></p>
<ul>
<li>The <code>SetHeader</code> prefix indicates that this Property is intended
for setting HTTP response headers.</li>
<li><code>[Identifier]</code> is some string that relates to what this value is for.
It MUST NOT have upper-case characters after the first character.</li>
<li><code>[HeaderName]</code> is the name of the HTTP header to set in the response.</li>
</ul>
<h2 id="accepted-evidence">Accepted Evidence</h2>
<p>This element uses no Evidence, it works on Property values in Element Data
in the Flow Data.</p>
<h2 id="start-up-activity">Start-up activity</h2>
<p>For performance reasons, it is usually best to construct a list of
Properties with the <code>SetHeader</code> prefix on start-up, rather than doing
so for each request.</p>
<h2 id="element-data">Element Data</h2>
<table>
<thead>
<tr><th> <strong>Name</strong>                   </th><th> <strong>Type</strong>                              </th><th> <strong>Description</strong>                                                                                                                           </th></tr>
</thead>
<tbody>
<tr><td> response-header-dictionary </td><td> <code>IReadOnlyDictionary&lt;string, string&gt;</code> </td><td> A collection of key value pairs where the key is the HTTP response header name and the value is the value to set that response header to. </td></tr>
</tbody>
</table>
<h2 id="process">Process</h2>
<ul>
<li>Get all Properties in Flow Data with <code>SetHeader</code> at the start of the name.</li>
<li>For each Property</li>
<li>If Property value is set and is not <code>Unknown</code>
<ul>
<li>Extract the header name from the Property name using the convention
outlined <a href="#overview">above</a>. Use this as the key to the output key value
pair collection.</li>
<li>Split the Property value using <code>,</code> and add each individual segment to
the output collection if it has not yet been added for that key.</li>
</ul>
</li>
</ul>
<h2 id="configuration-options">Configuration options</h2>
<p>None</p>

<hr/>
<h1 id="usage-sharing-element">Usage sharing element</h1>
<h2 id="overview">Overview</h2>
<p>This <strong>Flow Element</strong> implements the <a href="../features/usage-sharing.md">usage-sharing</a>
feature.</p>
<h2 id="accepted-evidence">Accepted Evidence</h2>
<p>The EvidenceKeyFilter for share usage is unusual as it cannot simply be a
list of accepted keys like most <strong>Flow Elements</strong>.</p>
<p>Instead, it is a filter function that should return false (i.e. not shared)
for any key where:</p>
<ul>
<li>Prefix = header and field is in a user-configurable block list
(by default, this block list must include the cookies header).</li>
<li>Prefix = cookie and field does not start with <code>51D_</code></li>
<li>Prefix = query and field does not start with <code>51D_</code> and is not in a
user-configurable allow list of query string parameters that should be
shared.</li>
</ul>
<p>Anything else should return true. (i.e. it will be shared)</p>
<p>See <a href="#configuration-options">configuration options</a> for more detail on the
configuration parameters that can affect this filter function.</p>
<h2 id="element-data">Element Data</h2>
<p>This <strong>Flow Element</strong> does not add an <strong>Element Data</strong> instance to <strong>Flow Data</strong>.</p>
<h2 id="start-up-activity">Start-up activity</h2>
<p>A static XML snippet can be generated for values that will be invariant
for the lifetime of the current <strong>Pipeline</strong>.</p>
<p>From the list of parameters in the processing section below, the invariant ones
are:
- Version
- Product
- Flow Elements
- Language
- LanguageVersion
- ServerIP
- Platform</p>
<p>Note that there is a proposal to reduce the size of the usage sharing payload
by moving these values to a <code>header</code> element rather than duplicating them in
every <code>device</code> element.
Implementing this will be a future enhancement as changes will first be required
to 51Degrees&rsquo; data collection infrastructure.</p>
<h2 id="processing">Processing</h2>
<p>The process function must get the data it needs and complete as soon as
possible.
We recommend implementing a producer/consumer approach where the process
function just adds the raw data to a shared queue.</p>
<p>A background thread can then be used to consume items from this queue,
adding them to the XML payload and sending it once it contains the
required quantity of data.</p>
<p>The complete XML document must contain a <code>&lt;Devices&gt;</code> root element with
each <code>&lt;Device&gt;</code> element containing the details related to a request.</p>
<p>Multiple <code>&lt;Device&gt;</code> elements will be batched up as part of each message.
The number of items per batch is configurable using the
<a href="#configuration-options">minimum entries per message</a> setting.</p>
<pre><code class="language-xml">&lt;Device&gt;
  &lt;SessionId&gt;SESSION_ID&lt;/SessionId&gt; 
  &lt;Sequence&gt;SEQUENCE&lt;/Sequence&gt; 
  &lt;DateSent&gt;DATE_SENT&lt;/DateSent&gt; 
  &lt;Version&gt;API_VERSION&lt;/Version&gt; 
  &lt;Product&gt;API_NAME&lt;/Product&gt;  
  &lt;FlowElement&gt;ELEMENT1&lt;/FlowElement&gt; 
  &lt;FlowElement&gt;ELEMENT2&lt;/FlowElement&gt;	 
  &lt;Language&gt;LANG&lt;/Language&gt; 
  &lt;LanguageVersion&gt;LANG_VERSION&lt;/LanguageVersion&gt; 
  &lt;ClientIP&gt;IP_ADDRESS&lt;/ClientIP&gt; 
  &lt;ServerIP&gt;IP_ADDRESS&lt;/ServerIP&gt; 
  &lt;Platform&gt;PLATFORM PLATFORM_VER SERVICE_PACK&lt;/Platform&gt; 
Each evidence value is represented as an entry in the form: 
  &lt;PREFIX [escaped=true] [truncated=true] Name=FIELD&gt;VALUE&lt;/PREFIX&gt; 
For example: 
  &lt;Header Name=User-Agent&gt;USER_AGENT&lt;/Header&gt; 
  &lt;Header Name=Host&gt;HOST&lt;/Header&gt;
  &lt;Cookie Name=51D_ScreenPixelsHeight&gt;1080&lt;/Cookie&gt; 
  [&lt;BadSchema&gt;true&lt;/BadSchema&gt;]
&lt;/Device&gt; 
</code></pre>
<ul>
<li><strong>SessionId</strong>  A GUID generated by the Share Usage element used to
identify a set of Evidence originating from the same source where
multiple requests are initiated to resolve the JSON payload for
updated Evidence, e.g. client-side overrides or geo location.</li>
<li><strong>Sequence</strong>  An integer paired with the SessionId which is incremented
each time the sequence value is seen in Evidence to identify the number
of requests in a session.</li>
<li><strong>DateSent</strong> - The date that the xml was constructed in UTC and formatted
as: yyyy-mm-ddThh:nn:ss</li>
<li><strong>Version</strong> - The version of the Pipeline that is being used to generate
the xml. E.g. 4.0</li>
<li><strong>Product</strong> - The name of the product that is generating the xml. For
example, Pipeline</li>
<li><strong>FlowElement</strong>  An xml element exists for each FlowElement in the
Pipeline. The text contains the fully qualified class name of the FlowElement.</li>
<li><strong>Language</strong> - The name of the language/framework within which the
Pipeline is running.</li>
<li><strong>LanguageVersion</strong> - The version number of the language/framework
within which the Pipeline is running.</li>
<li><strong>ClientIP</strong> - Public IP address of the client that sent the request to
this server.</li>
<li><strong>ServerIP</strong> - IP address of the server where the xml is being generated.</li>
<li><strong>Platform</strong> - The platform name, version and service pack if available.</li>
<li><strong>Evidence</strong>  The Evidence that is shared will be determined by its
Evidence key filter as defined below.</li>
</ul>
<p>Evidence values may be extremely long, or contain characters that are not
permitted in XML. In order to handle this, a function should be implemented
to sanitize the values before they are added to the XML.</p>
<p>Where changes need to be made, attributes should be added to the XML element
to let the reader know the value was modified.</p>
<p>See the <a href="https://github.com/51Degrees/pipeline-java/blob/master/pipeline.engines.fiftyone/src/main/java/fiftyone/pipeline/engines/fiftyone/flowelements/ShareUsageElement.java#L485">ReplacedString</a>
function in Java for an example of this.</p>
<h3 id="request-detail">Request detail</h3>
<p>When sending the data, use the following details:
- URL configurable using the <a href="#configuration-options">share usage URL</a> option.
- POST request
- XML content written to the body of the request using GZip compression
- HTTP Headers:
- content-encoding = gzip
- content-type = text/xml</p>
<p>Response will be a 200 on success. Anything else is a failure.
When failures occur, the status code and content of the response should be logged.</p>
<p>See the <a href="https://github.com/51Degrees/pipeline-dotnet/blob/master/FiftyOne.Pipeline.Engines.FiftyOne/FlowElements/ShareUsageElement.cs#L104">BuildAndSendXml</a> method in C# for an example of this.</p>
<h2 id="session-tracking">Session tracking</h2>
<p>Note that this section is not concerned with actually identifying
the precise boundaries of user sessions. Just with reducing the volume
of unnecessary data that is shared.</p>
<p>When a user is browsing a website, they may typically make many HTTP
requests to access different resources, visit different pages, etc.</p>
<p>These requests will usually all generate exactly the same usage data.
We have no need for this duplicate data, so it should be discarded as
early as possible.</p>
<p>The usage sharing element must maintain a data structure containing
recently shared Evidence values. If the data entry being processed
already has a matching entry in this data structure, it should not
be shared. For example, the C# implementation generates a hash of the
Evidence values using the same logic as the <a href="../features/caching.md">caching</a>
feature.</p>
<p>By default, entries will have a lifetime of 20 minutes within this
data structure. This is reset each time an entry with matching
Evidence values is processed.</p>
<p>See <a href="#configuration-options">configuration options</a> for more detail
on customizing this lifetime.</p>
<p>Note that certain Evidence values should not be included in this check
as they are designed to make a request unique.
Internally, this only applies to the sequence number generated by the
<a href="sequence-element.md">Sequence Element</a>.</p>
<p>We also include various <a href="#configuration-options">configuration options</a>
for users to exclude any keys that may be identified to cause
oversharing of data.</p>
<h2 id="error-handling">Error handling</h2>
<p>As a general principle, share usage should be considered an expendable
activity. If errors occur then they should be handled and
<a href="../features/logging.md">logged</a> without disrupting anything else.</p>
<p>For example, the queue of data to be sent has limited size. If this
becomes full additional data should simply be discarded until there
is room to add entries again.
However, it is important that these actions are logged so that users
can identify potential issues with their usage sharing.</p>
<h2 id="cleanup">Cleanup</h2>
<p>As this element uses a producer/consumer queue and background processing,
it will need to handle cleanup a little more carefully than other elements.</p>
<ol>
<li>If needed, block while the consumer sends data waiting in the queue.</li>
<li>Send a final message with any data remaining in the queue (even if it is
less than the configured minimum batch size)</li>
<li>Free any resources associated with the queue and background processing.</li>
</ol>
<h2 id="configuration-options">Configuration options</h2>
<table>
<thead>
<tr><th> <strong>Parameter</strong>                     </th><th> <strong>User configurable</strong> </th><th> <strong>Optional</strong> </th><th> <strong>Default</strong>                                                                  </th><th> <strong>Notes</strong>                                                                                                                      </th></tr>
</thead>
<tbody>
<tr><td> Included query string parameters  </td><td> yes                   </td><td> yes          </td><td> All query string and HTTP form parameters starting with <code>51D_</code> are shared.   </td><td> Allows the user to include specific query string or HTTP form parameters in the usage data that is shared.                     </td></tr>
<tr><td> Share all query string parameters </td><td> yes                   </td><td> yes          </td><td> false                                                                        </td><td> If this flag is set, all query string and HTTP form parameters will be shared.                                                 </td></tr>
<tr><td> Share all Evidence                </td><td> yes                   </td><td> yes          </td><td> false                                                                        </td><td> If this flag is set, all Evidence values will be shared.                                                                       </td></tr>
<tr><td> Blocked HTTP headers              </td><td> yes                   </td><td> yes          </td><td> All HTTP headers are shared except for cookies that do not start with <code>51D_</code> </td><td> Allows the user to exclude specific HTTP headers that they do not want to share.                                               </td></tr>
<tr><td> Ignore Flow Data Evidence filter  </td><td> yes                   </td><td> yes          </td><td> not set                                                                      </td><td> Allows the user to block a request from being shared if the specified criteria are met.                                        </td></tr>
<tr><td> Share percentage                  </td><td> yes                   </td><td> yes          </td><td> 1.0                                                                          </td><td> Used to set the approximate proportion of requests that should be shared. A value of 1 means that 100% of requests are shared. </td></tr>
<tr><td> Minimum entries per message       </td><td> yes                   </td><td> yes          </td><td> 50                                                                           </td><td> The number of requests that must be added to a usage sharing payload before it is sent.                                        </td></tr>
<tr><td> Maximum queue size                </td><td> yes                   </td><td> yes          </td><td> 1000                                                                         </td><td> The size of the queue that is used to buffer requests to be added to a usage sharing payload.                                  </td></tr>
<tr><td> Add timeout milliseconds          </td><td> yes                   </td><td> yes          </td><td> 5                                                                            </td><td> The timeout to use when trying to add items to the usage sharing queue. If the request times out, the data should be discarded </td></tr>
<tr><td> Take timeout milliseconds         </td><td> yes                   </td><td> yes          </td><td> 100                                                                          </td><td> The timeout to use when getting items from the usage sharing queue to add to the next payload.                                 </td></tr>
<tr><td> Share usage URL                   </td><td> yes                   </td><td> yes          </td><td> <a href="https://devices-v4.51degrees.com/new.ashx">https://devices-v4.51degrees.com/new.ashx</a>                                    </td><td> The URL to send data to                                                                                                        </td></tr>
<tr><td> Repeat Evidence interval minutes  </td><td> yes                   </td><td> yes          </td><td> 20                                                                           </td><td> The size of the sliding window during which identical usage data will not be sent if it is seen second or subsequent times.    </td></tr>
</tbody>
</table>

<hr/>

</body></html>